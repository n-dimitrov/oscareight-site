<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="3Gu5CK-uAJJY2tzYRhDu7x06dXa-0Ww81kn8VcFM9Dg">
    <title>OscarEight - Academy Awards Explorer</title>
    <link rel="stylesheet" href="css/main.28fd78.css">
</head>
<body>
    <div class="backdrop" aria-hidden="true">
        <div class="orb orb--one"></div>
        <div class="orb orb--two"></div>
        <div class="orb orb--three"></div>
        <div class="gridlines"></div>
    </div>
    
    <!-- Authentication Section -->
    <div class="auth-section">
        <div id="authContainer">
            <!-- Sign in button (shown when not authenticated) -->
            <button id="signInButton" class="auth-button" style="display: none;">
                Sign In
            </button>
            
            <!-- User menu (shown when authenticated) -->
            <div id="userMenu" class="user-menu" style="display: none;">
                <button id="userMenuButton" class="auth-button">
                    <img id="userAvatar" src="" alt="User avatar" class="user-avatar">
                    <span id="userName"></span>
                </button>
                <div id="userDropdown" class="user-dropdown">
                    <div class="dropdown-item" style="font-weight: 600;" id="userDropdownName"></div>
                    <div class="dropdown-item" style="font-weight: 600;" id="userEmail"></div>
                    <div class="dropdown-item country-row" style="font-weight: 600;">
                        <span id="userCountry"></span>
                        <button id="userCountryToggle" class="country-toggle" type="button">Change</button>
                    </div>
                    <div class="dropdown-item">
                        <select id="userCountrySelect" class="country-select is-hidden" aria-label="Select country"></select>
                    </div>
                    <div class="dropdown-divider"></div>
                    <button class="dropdown-item" id="badgesButton">Badges</button>
                    <div class="dropdown-divider"></div>
                    <button class="dropdown-item" id="signOutButton">Sign out</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Sign In Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-modal-content">
            <button class="auth-close" id="closeAuthModal" aria-label="Close">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                    <line x1="6" y1="18" x2="18" y2="6"></line>
                </svg>
            </button>
            <div class="auth-modal-header">
                <h2>Sign In</h2>
                <p>Choose a method to sign in to OscarEight</p>
            </div>
            <div class="auth-methods">
                <button id="googleSignInButton" class="auth-provider-button">
                    <svg width="20" height="20" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
                        <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                        <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                        <path fill="#FBBC05" d="M3.964 10.707c-.18-.54-.282-1.117-.282-1.707s.102-1.167.282-1.707V4.958H.957C.347 6.173 0 7.548 0 9s.348 2.827.957 4.042l3.007-2.335z"/>
                        <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z"/>
                    </svg>
                    Continue with Google
                </button>
                
                <!-- Ready for more providers -->
                <!-- <div class="auth-divider">or</div> -->
                <!-- Add more auth provider buttons here -->
            </div>
        </div>
    </div>
    
    <div class="container">
        <header class="hero">
            <h1 class="hero-title">
                <img class="hero-logo" src="oscareight-logo.png" alt="OscarEight logo">
                OscarEight
            </h1>
            <p>Explore winners and nominees in the 8 major categories since 1977</p>
        </header>

        <section class="poster-strip is-empty" id="posterStripSection">
                <button id="postersWallOpen" class="poster-wall-button tooltip-trigger" type="button" aria-label="Open posters wall" data-tooltip="Poster Wall">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <rect x="3" y="3" width="6" height="6" rx="1.5"></rect>
                    <rect x="15" y="3" width="6" height="6" rx="1.5"></rect>
                    <rect x="3" y="15" width="6" height="6" rx="1.5"></rect>
                    <rect x="15" y="15" width="6" height="6" rx="1.5"></rect>
                </svg>
            </button>
            <div class="poster-strip-track" id="posterStrip"></div>
            <div class="poster-strip-info" id="posterStripInfo" aria-live="polite"></div>
        </section>

        <div class="filters">
            <button class="expandable-toggle" id="filtersToggle" type="button" aria-expanded="false" aria-controls="filtersControls">
                Filters
                <span class="expandable-toggle-icon" aria-hidden="true"></span>
            </button>
            <div class="controls is-collapsed" id="filtersControls">
            <div class="control-group">
                <label for="yearSelect" class="field-label">Select Year</label>
                <select id="yearSelect">
                    <option value="">All Years</option>
                </select>
            </div>
            <div class="control-group">
                <label for="categorySelect" class="field-label">Filter by Category</label>
                <select id="categorySelect">
                    <option value="">All Categories</option>
                </select>
            </div>
            <div class="search-box">
                <label for="searchInput" class="field-label">Search Movie/Person</label>
                <input type="text" id="searchInput" placeholder="Search for films, actors, directors...">
            </div>
            <div class="toggle-group">
                <input type="checkbox" id="toggleNominees" checked>
                <label for="toggleNominees">Show Nominees</label>
            </div>
            </div>
        </div>

        <div id="resultsInfo"></div>

        <div class="content">
            <div class="card">
                <div class="card-header">
                    <div class="expandable-toggle movies-toggle" id="moviesToggle" role="button" tabindex="0" aria-expanded="true" aria-controls="resultsContainer">
                        Movies
                        <span id="resultsCount" class="count-chips">
                            <span class="count-pill"><button id="moviesCountButton" class="count-link" type="button">0 movies</button></span>
                        </span>
                        <span class="expandable-toggle-icon" aria-hidden="true"></span>
                    </div>
                </div>
                <div id="resultsContainer"></div>
            </div>
        </div>

        <footer>
            <p>Movie posters and data provided by <a href="https://www.themoviedb.org/" target="_blank" rel="noopener">TMDb</a>.</p>
            <p>OscarEight is not affiliated with the Academy of Motion Picture Arts and Sciences.</p>
        </footer>
    </div>

    <div id="moviesModal" class="modal" aria-hidden="true">
        <button class="modal-close" type="button" aria-label="Close">
            <svg viewBox="0 0 24 24" aria-hidden="true">
                <line x1="6" y1="6" x2="18" y2="18"></line>
                <line x1="6" y1="18" x2="18" y2="6"></line>
            </svg>
        </button>
        <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="moviesModalTitle">
            <div class="modal-header">
                <div class="modal-header-content">
                    <div id="moviesModalTitle" class="modal-title">Movies</div>
                    <div id="moviesModalCounts" class="count-chips">
                        <span class="count-pill">0 W</span>
                        <span class="count-pill">0 N</span>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <div id="letterRail" class="letter-rail" aria-label="Movie index"></div>
                <div id="moviesTable" class="modal-table"></div>
            </div>
        </div>
    </div>

    <div id="badgesModal" class="modal" aria-hidden="true">
        <button class="modal-close" id="badgesClose" type="button" aria-label="Close">
            <svg viewBox="0 0 24 24" aria-hidden="true">
                <line x1="6" y1="6" x2="18" y2="18"></line>
                <line x1="6" y1="18" x2="18" y2="6"></line>
            </svg>
        </button>
        <div class="modal-card badge-modal-card" role="dialog" aria-modal="true" aria-labelledby="badgesModalTitle">
            <div class="modal-header">
                <div class="modal-header-content">
                    <div id="badgesModalTitle" class="modal-title">Badges</div>
                    <div id="badgesSummary" class="badge-summary"></div>
                </div>
            </div>
            <div class="badge-filters">
                <div class="badge-filter-group">
                    <label class="badge-filter-label" for="badgeStatusFilter">Status</label>
                    <select id="badgeStatusFilter" class="badge-filter-select">
                        <option value="all">All</option>
                        <option value="earned" selected>Earned</option>
                        <option value="almost-done">One Away</option>
                        <option value="in-progress">In Progress</option>
                        <option value="locked">Locked</option>
                    </select>
                </div>
                <div class="badge-filter-group">
                    <label class="badge-filter-label" for="badgeTypeFilter">Type</label>
                    <select id="badgeTypeFilter" class="badge-filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                <div class="badge-filter-group">
                    <label class="badge-filter-label" for="badgeVariantFilter">Variant</label>
                    <select id="badgeVariantFilter" class="badge-filter-select">
                        <option value="all">All</option>
                    </select>
                </div>
                <div id="badgeFilterCount" class="badge-filter-count"></div>
            </div>
            <div class="modal-body badge-body">
                <div id="badgesGrid" class="badge-grid"></div>
            </div>
        </div>
    </div>

    <div id="movieDetailModal" class="detail-modal" aria-hidden="true">
        <button class="detail-close" type="button" aria-label="Close">
            <svg viewBox="0 0 24 24" aria-hidden="true">
                <line x1="6" y1="6" x2="18" y2="18"></line>
                <line x1="6" y1="18" x2="18" y2="6"></line>
            </svg>
        </button>
        <div class="detail-card" role="dialog" aria-modal="true" aria-labelledby="movieDetailTitle">
            <div class="detail-card-body">
                <img id="movieDetailPoster" class="detail-poster" alt="">
                <div class="detail-content">
                    <div class="detail-title-row">
                        <div id="movieDetailTitle" class="detail-title"></div>
                        <button id="watchedToggle" class="watched-toggle tooltip-trigger" type="button" aria-pressed="false" aria-label="Sign in to track watched" data-tooltip="Sign in to track watched">
                            <span class="watched-icon watched-icon--on" aria-hidden="true">&#10003;</span>
                            <span class="watched-icon watched-icon--off" aria-hidden="true">&#10003;</span>
                            <span class="watched-label" id="watchedLabel">Not watched</span>
                        </button>
                    </div>
                    <div class="detail-scroll">
                        <div id="movieDetailMeta" class="detail-meta"></div>
                        <div id="movieDetailOverview" class="detail-overview"></div>
                        <div id="movieDetailProviders" class="detail-providers"></div>
                        <div id="movieDetailCategories" class="detail-categories"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="postersWallModal" class="wall-modal" aria-hidden="true">
        <div class="wall-modal-content" role="dialog" aria-modal="true" aria-label="Posters Wall">
            <div class="wall-controls" role="toolbar" aria-label="Poster wall controls">
                <button id="postersWallPlay" class="wall-control" type="button" aria-label="Play shuffle">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <polygon points="9 7 17 12 9 17"></polygon>
                    </svg>
                </button>
                <button id="postersWallShuffle" class="wall-control" type="button" aria-label="Shuffle posters">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M16 3h5v5"></path>
                        <path d="M21 3l-7.5 7.5"></path>
                        <path d="M3 7h4.5l2.5 2.5"></path>
                        <path d="M16 21h5v-5"></path>
                        <path d="M21 21l-7.5-7.5"></path>
                        <path d="M3 17h4.5l2.5-2.5"></path>
                    </svg>
                </button>
                <button id="postersWallFullscreen" class="wall-control" type="button" aria-label="Toggle fullscreen">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M8 3H3v5"></path>
                        <path d="M3 3l6 6"></path>
                        <path d="M16 3h5v5"></path>
                        <path d="M21 3l-6 6"></path>
                        <path d="M3 16v5h5"></path>
                        <path d="M3 21l6-6"></path>
                        <path d="M21 16v5h-5"></path>
                        <path d="M21 21l-6-6"></path>
                    </svg>
                </button>
            </div>
            <button class="wall-control wall-modal-close" type="button" aria-label="Close">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                    <line x1="6" y1="18" x2="18" y2="6"></line>
                </svg>
            </button>
            <div id="postersWallGrid" class="wall-grid"></div>
            <div id="postersWallTooltip" class="wall-poster-tooltip-overlay" aria-live="polite"></div>
            <div id="postersWallCountdown" class="wall-countdown" aria-live="polite"></div>
        </div>
    </div>

    <script type="module">
        import { oscarsData, moviesData } from './js/data.js';

        const state = {
            selectedYear: null,
            selectedCategory: null,
            searchQuery: '',
            showNominees: false,
            filtersExpanded: false,
            moviesExpanded: true
        };

        let posterStripReady = false;
        const posterStripHighlightMs = 3000;
        const posterStripShuffleDelayMs = 2000;
        const posterStripResizeWidthThreshold = 6;
        let posterStripHighlightTimer = null;
        let posterStripShuffleTimer = null;
        let posterStripHighlightIndex = 0;
        let posterStripPaused = false;
        let posterStripAutoPaused = false;
        let posterStripIsResizing = false;
        let posterStripLastCapacity = null;
        let posterStripLastWidth = null;
        let posterStripScrollResumeTimer = null;
        let posterStripViewportResizeTimer = null;
        let postersWallOpen = false;
        let postersWallResizeTimer = null;
        let postersWallUiTimer = null;
        let postersWallIdleTimer = null;
        let postersWallCountdownTimer = null;
        let postersWallCountdownValue = 0;
        let postersWallSelection = [];
        let postersWallShuffleTimer = null;
        let postersWallIsShuffling = false;
        let postersWallActiveWrap = null;
        const postersWallScale = 0.98;

        let latestMovieStats = [];
        let latestWinnerCount = 0;
        let latestNomineeCount = 0;
        let tableSort = { key: 'title', direction: 'asc' };
        let globalMovieStats = null;

        const categoryOrder = [
            'Best Picture',
            'Best Director',
            'Best Actor',
            'Best Actress',
            'Best Supporting Actor',
            'Best Supporting Actress',
            'Best Original Screenplay',
            'Best Adapted Screenplay'
        ];

        function getGlobalMovieStats() {
            if (globalMovieStats) return globalMovieStats;
            const stats = {};
            const getKey = (movie, year) => {
                if (movie && movie.id) return `id:${movie.id}`;
                return `title:${movie.title || ''}__${year || ''}`;
            };
            const ensureEntry = (key) => {
                if (!stats[key]) {
                    stats[key] = { wins: 0, nominations: 0, names: new Set() };
                }
                return stats[key];
            };

            Object.keys(oscarsData).forEach(year => {
                const yearData = oscarsData[year] || {};
                categoryOrder.forEach(category => {
                    const categoryData = yearData[category];
                    if (!categoryData) return;

                    const winner = categoryData.winner;
                    if (winner) {
                        const key = getKey(winner, year);
                        const entry = ensureEntry(key);
                        entry.wins += 1;
                        entry.nominations += 1;
                        (winner.names || []).forEach(name => entry.names.add(name));
                    }

                    (categoryData.nominees || []).forEach(nominee => {
                        const key = getKey(nominee, year);
                        const entry = ensureEntry(key);
                        entry.nominations += 1;
                        (nominee.names || []).forEach(name => entry.names.add(name));
                    });
                });
            });

            globalMovieStats = stats;
            return globalMovieStats;
        }

        // Initialize
        function init() {
            populateYearSelect();
            populateCategorySelect();
            setupEventListeners();
            setFiltersExpanded(state.filtersExpanded);
            setMoviesExpanded(state.moviesExpanded);
            document.getElementById('toggleNominees').checked = state.showNominees;
            render();
            window.addEventListener('load', () => {
                posterStripReady = true;
                renderPosterStrip();
                setupLazyPosters();
            }, { once: true });
        }

        function populateYearSelect() {
            const years = Object.keys(oscarsData).sort((a, b) => parseInt(b) - parseInt(a));
            const select = document.getElementById('yearSelect');
            years.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                select.appendChild(option);
            });
        }

        function populateCategorySelect() {
            const select = document.getElementById('categorySelect');
            categoryOrder.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                select.appendChild(option);
            });
        }

        function setupEventListeners() {
            document.getElementById('filtersToggle').addEventListener('click', () => {
                state.filtersExpanded = !state.filtersExpanded;
                setFiltersExpanded(state.filtersExpanded);
            });

            document.getElementById('moviesToggle').addEventListener('click', () => {
                state.moviesExpanded = !state.moviesExpanded;
                setMoviesExpanded(state.moviesExpanded);
            });

            document.getElementById('moviesToggle').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    state.moviesExpanded = !state.moviesExpanded;
                    setMoviesExpanded(state.moviesExpanded);
                }
            });

            const posterStripSection = document.getElementById('posterStripSection');
            const posterStripTrack = document.getElementById('posterStrip');
            posterStripSection.addEventListener('mouseenter', pausePosterStrip);
            posterStripSection.addEventListener('mouseleave', resumePosterStrip);
            posterStripSection.addEventListener('focusin', pausePosterStrip);
            posterStripSection.addEventListener('focusout', (e) => {
                if (!posterStripSection.contains(e.relatedTarget)) {
                    resumePosterStrip();
                }
            });
            posterStripTrack.addEventListener('click', (e) => {
                const button = e.target.closest('.poster-strip-button');
                if (button && button.dataset.movieId) {
                    pausePosterStrip();
                    openMovieDetail(button.dataset.movieId);
                }
            });

            const posterStripInfo = document.getElementById('posterStripInfo');
            if (posterStripInfo) {
                posterStripInfo.addEventListener('click', (e) => {
                    const button = e.target.closest('.poster-strip-info-title');
                    if (button && button.dataset.movieId) {
                        pausePosterStrip();
                        openMovieDetail(button.dataset.movieId);
                    }
                });
            }

            const postersWallOpenButton = document.getElementById('postersWallOpen');
            if (postersWallOpenButton) {
                postersWallOpenButton.addEventListener('click', openPostersWall);
            }
            const postersWallShuffleButton = document.getElementById('postersWallShuffle');
            if (postersWallShuffleButton) {
                postersWallShuffleButton.addEventListener('click', () => {
                    shufflePostersWall();
                });
            }
            const postersWallFullscreenButton = document.getElementById('postersWallFullscreen');
            if (postersWallFullscreenButton) {
                postersWallFullscreenButton.addEventListener('click', togglePostersWallFullscreen);
            }

            const schedulePosterStripResize = () => {
                if (posterStripReady) {
                    const section = document.getElementById('posterStripSection');
                    const track = document.getElementById('posterStrip');
                    if (section && track) {
                        const currentWidth = section.getBoundingClientRect().width || section.clientWidth || 0;
                        if (!currentWidth) {
                            return;
                        }
                        const nextCapacity = getPosterStripCapacity();
                        if (posterStripLastCapacity !== null && nextCapacity === posterStripLastCapacity) {
                            return;
                        }
                        if (posterStripLastWidth !== null
                            && Math.abs(currentWidth - posterStripLastWidth) < posterStripResizeWidthThreshold) {
                            return;
                        }
                        if (!posterStripIsResizing) {
                            posterStripIsResizing = true;
                            autoPausePosterStrip();
                            track.innerHTML = '<div class="poster-strip-loading">Loadingâ€¦</div>';
                            updatePosterStripInfo(null);
                            section.classList.add('is-resizing');
                        }
                    }
                }
                if (posterStripViewportResizeTimer) {
                    clearTimeout(posterStripViewportResizeTimer);
                }
                posterStripViewportResizeTimer = window.setTimeout(() => {
                    if (!posterStripReady) return;
                    const nextCapacity = getPosterStripCapacity();
                    if (posterStripLastCapacity !== null && nextCapacity === posterStripLastCapacity) {
                        if (posterStripIsResizing) {
                            const section = document.getElementById('posterStripSection');
                            if (section) {
                                section.classList.remove('is-resizing');
                            }
                            posterStripIsResizing = false;
                            autoResumePosterStrip();
                        }
                        return;
                    }
                    renderPosterStrip();
                    setupLazyPosters();
                    const section = document.getElementById('posterStripSection');
                    if (section) {
                        section.classList.remove('is-resizing');
                    }
                    posterStripIsResizing = false;
                    autoResumePosterStrip();
                }, 1500);
            };

            window.addEventListener('resize', schedulePosterStripResize);
            window.addEventListener('resize', schedulePostersWallResize);

            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', schedulePosterStripResize);
                window.visualViewport.addEventListener('resize', schedulePostersWallResize);
            }

            window.addEventListener('scroll', () => {
                autoPausePosterStrip();
                if (posterStripScrollResumeTimer) {
                    clearTimeout(posterStripScrollResumeTimer);
                }
                posterStripScrollResumeTimer = window.setTimeout(() => {
                    autoResumePosterStrip();
                }, 180);
            }, { passive: true });

            document.getElementById('yearSelect').addEventListener('change', (e) => {
                state.selectedYear = e.target.value || null;
                render();
            });

            document.getElementById('categorySelect').addEventListener('change', (e) => {
                state.selectedCategory = e.target.value || null;
                render();
            });

            document.getElementById('searchInput').addEventListener('input', (e) => {
                state.searchQuery = e.target.value.toLowerCase();
                render();
            });

            document.getElementById('toggleNominees').addEventListener('change', (e) => {
                state.showNominees = e.target.checked;
                render();
            });

            document.getElementById('resultsCount').addEventListener('click', (e) => {
                if (e.target && e.target.id === 'moviesCountButton') {
                    e.stopPropagation();
                    openMoviesModal();
                }
            });

            document.getElementById('resultsContainer').addEventListener('click', (e) => {
                const button = e.target.closest('.movie-link');
                if (button && button.dataset.movieId) {
                    openMovieDetail(button.dataset.movieId);
                }
            });

            document.querySelector('.modal-close').addEventListener('click', closeMoviesModal);
            document.getElementById('moviesModal').addEventListener('click', (e) => {
                if (e.target.id === 'moviesModal') {
                    closeMoviesModal();
                }
            });

            document.addEventListener('fullscreenchange', updatePostersWallFullscreenState);

            const postersWallModal = document.getElementById('postersWallModal');
            const postersWallClose = document.querySelector('.wall-modal-close');
            if (postersWallClose) {
                postersWallClose.addEventListener('click', closePostersWall);
            }
            if (postersWallModal) {
                const wallActivity = () => {
                    if (postersWallOpen) {
                        showPostersWallUi();
                        resetPostersWallInactivity();
                    }
                };
                postersWallModal.addEventListener('mousemove', wallActivity);
                postersWallModal.addEventListener('touchstart', wallActivity, { passive: true });
                postersWallModal.addEventListener('click', wallActivity);
                postersWallModal.addEventListener('click', (e) => {
                    if (!postersWallOpen) return;
                    const wrap = e.target.closest('.wall-poster-wrap');
                    if (postersWallActiveWrap && postersWallActiveWrap !== wrap) {
                        hidePostersWallTooltip();
                    }
                    if (wrap) {
                        if (postersWallActiveWrap === wrap) {
                            hidePostersWallTooltip();
                        } else {
                            showPostersWallTooltip(wrap);
                        }
                        return;
                    }
                    hidePostersWallTooltip();
                });
                postersWallModal.addEventListener('click', (e) => {
                    if (e.target.id === 'postersWallModal') {
                        closePostersWall();
                    }
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeMoviesModal();
                    closeMovieDetail();
                    closePostersWall();
                    closeBadgesModal();
                }
            });

            document.querySelector('.detail-close').addEventListener('click', closeMovieDetail);
            document.getElementById('movieDetailModal').addEventListener('click', (e) => {
                if (e.target.id === 'movieDetailModal') {
                    closeMovieDetail();
                }
            });
        }

        function setFiltersExpanded(isExpanded) {
            const toggle = document.getElementById('filtersToggle');
            const controls = document.getElementById('filtersControls');
            toggle.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
            controls.classList.toggle('is-collapsed', !isExpanded);
        }

        function setMoviesExpanded(isExpanded) {
            const toggle = document.getElementById('moviesToggle');
            const container = document.getElementById('resultsContainer');
            toggle.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');
            container.classList.toggle('is-collapsed', !isExpanded);
        }

        function getDisplayData() {
            let years = state.selectedYear
                ? [state.selectedYear]
                : Object.keys(oscarsData).sort((a, b) => parseInt(b) - parseInt(a));

            const results = [];

            years.forEach(year => {
                const yearData = oscarsData[year];
                let categories = state.selectedCategory
                    ? [state.selectedCategory]
                    : categoryOrder.filter(cat => yearData[cat]);

                categories.forEach(category => {
                    const categoryData = yearData[category];
                    if (!categoryData) return;

                    results.push({
                        year,
                        category,
                        winner: categoryData.winner,
                        nominees: categoryData.nominees || []
                    });
                });
            });

            return results;
        }

        function matchesSearch(item) {
            if (!state.searchQuery) return true;

            const searchStr = state.searchQuery;
            const title = (item.title || '').toLowerCase();
            const names = (item.names || []).map(n => n.toLowerCase()).join(' ');

            return title.includes(searchStr) || names.includes(searchStr);
        }

        function getWatchedCountForStats() {
            if (!window.getWatchedIds) return null;
            const watchedIds = window.getWatchedIds();
            if (!watchedIds) return null;
            let watchedCount = 0;
            latestMovieStats.forEach(movie => {
                if (movie.id && watchedIds.has(movie.id)) {
                    watchedCount += 1;
                }
            });
            return watchedCount;
        }

        function updateResultsCount() {
            const resultsCount = document.getElementById('resultsCount');
            const modalCounts = document.getElementById('moviesModalCounts');
            const uniqueCount = latestMovieStats.length;
            const watchedCount = getWatchedCountForStats();
            const moviesCountHtml = watchedCount === null
                ? `
                    <span class="count-pill count-pill--stacked">
                        <span class="count-pill-value">
                            <button id="moviesCountButton" class="count-link" type="button">${uniqueCount}</button>
                        </span>
                        <span class="count-pill-label">Movies</span>
                    </span>
                `
                : `
                    <span class="count-pill count-pill--combo">
                        <span class="count-pill-grid">
                            <span class="count-pill-value">${watchedCount}</span>
                            <span class="count-pill-value">
                                <button id="moviesCountButton" class="count-link" type="button">${uniqueCount}</button>
                            </span>
                            <span class="count-pill-label">Watched</span>
                            <span class="count-pill-label">Movies</span>
                        </span>
                    </span>
                `;

            resultsCount.innerHTML = moviesCountHtml.trim();

            if (modalCounts) {
                const globalStats = getGlobalMovieStats();
                const getGlobalKey = (movie) => {
                    if (movie.id) return `id:${movie.id}`;
                    return `title:${movie.title || ''}__${movie.year || ''}`;
                };
                let totalWins = 0;
                let totalNominations = 0;
                latestMovieStats.forEach(movie => {
                    const entry = globalStats[getGlobalKey(movie)];
                    if (!entry) return;
                    totalWins += entry.wins || 0;
                    totalNominations += entry.nominations || 0;
                });
                const moviesPill = watchedCount === null
                    ? `
                        <span class="count-pill count-pill--stacked">
                            <span class="count-pill-value">${uniqueCount}</span>
                            <span class="count-pill-label">Movies</span>
                        </span>
                    `
                    : `
                        <span class="count-pill count-pill--combo">
                            <span class="count-pill-grid">
                                <span class="count-pill-value">${watchedCount}</span>
                                <span class="count-pill-value">${uniqueCount}</span>
                                <span class="count-pill-label">Watched</span>
                                <span class="count-pill-label">Movies</span>
                            </span>
                        </span>
                    `;
                modalCounts.innerHTML = `
                    <span class="count-pill count-pill--combo">
                        <span class="count-pill-grid">
                            <span class="count-pill-value">${totalWins}</span>
                            <span class="count-pill-value">${totalNominations}</span>
                            <span class="count-pill-label">Oscars</span>
                            <span class="count-pill-label">Nominees</span>
                        </span>
                    </span>
                    ${moviesPill}
                `.trim();
            }
        }

        window.updateResultsCount = updateResultsCount;

        function getPosterUrl(movieId) {
            if (!movieId || !moviesData[movieId] || !moviesData[movieId].poster_path) {
                return '';
            }
            return `https://image.tmdb.org/t/p/w154${moviesData[movieId].poster_path}`;
        }

        function getWallPosterUrl(movieId) {
            if (!movieId || !moviesData[movieId] || !moviesData[movieId].poster_path) {
                return '';
            }
            return `https://image.tmdb.org/t/p/w342${moviesData[movieId].poster_path}`;
        }

        function getPosterWallLayout() {
            const modalContent = document.querySelector('.wall-modal-content');
            const isNarrow = window.innerWidth <= 980;
            const padding = isNarrow ? 16 : 14;
            const gap = isNarrow ? 6 : 8;
            const contentRect = modalContent ? modalContent.getBoundingClientRect() : null;
            const maxWidth = Math.max(0, (contentRect ? contentRect.width : window.innerWidth) - padding * 2);
            const maxHeight = Math.max(0, (contentRect ? contentRect.height : window.innerHeight) - padding * 2);
            const availableHeight = Math.max(0, maxHeight - gap * 2);
            const minPosterWidth = isNarrow ? 90 : 110;
            const aspectRatio = 1.5;
            let best = null;
            const maxCols = Math.min(12, Math.max(2, Math.floor((maxWidth + gap) / (minPosterWidth + gap))));

            for (let cols = 2; cols <= maxCols; cols += 1) {
                const posterWidth = Math.floor(((maxWidth - gap * (cols - 1)) / cols) * postersWallScale);
                if (posterWidth < minPosterWidth) continue;
                const posterHeight = Math.floor(posterWidth * aspectRatio);
                const rows = Math.floor((availableHeight + gap) / (posterHeight + gap));
                if (rows < 1) continue;
                const capacity = rows * cols;
                if (!best || capacity > best.capacity || (capacity === best.capacity && posterWidth > best.posterWidth)) {
                    best = {
                        cols,
                        rows,
                        gap,
                        posterWidth,
                        posterHeight,
                        capacity
                    };
                }
            }

            if (best) {
                return best;
            }

            const posterWidth = Math.floor(Math.min(maxWidth, availableHeight / aspectRatio) * postersWallScale);
            const posterHeight = Math.floor(posterWidth * aspectRatio);
            return {
                cols: 1,
                rows: 1,
                gap,
                posterWidth,
                posterHeight,
                capacity: 1
            };
        }

        function getPostersWallPool() {
            return latestMovieStats
                .map(movie => ({
                    id: movie.id,
                    title: movie.title || '',
                    url: getWallPosterUrl(movie.id)
                }))
                .filter(poster => poster.url);
        }

        function getPostersWallSelection(layout) {
            const posters = getPostersWallPool();
            shuffleArray(posters);
            return posters.slice(0, layout.capacity);
        }

        function getPostersWallColumns(selection, layout) {
            const columns = [];
            for (let col = 0; col < layout.cols; col += 1) {
                const column = [];
                for (let row = 0; row < layout.rows; row += 1) {
                    const index = row * layout.cols + col;
                    if (selection[index]) {
                        column.push(selection[index]);
                    }
                }
                columns.push(column);
            }
            return columns.filter(column => column.length > 0);
        }

        function getCenteredWallColumns(selection, layout) {
            const count = selection.length;
            if (count === 0) {
                return {
                    columns: Array.from({ length: layout.cols }, () => []),
                    padTop: 0
                };
            }

            const gridAspect = layout.rows / layout.cols;
            let best = null;

            for (let rows = 1; rows <= layout.rows; rows += 1) {
                for (let cols = 1; cols <= layout.cols; cols += 1) {
                    if (rows * cols < count) continue;
                    const area = rows * cols;
                    const balance = Math.max(rows / cols, cols / rows);
                    const skinnyPenalty = (rows === 1 || cols === 1) && count > 4 ? 10 : 0;
                    const aligns = Math.abs((rows / cols) - gridAspect);
                    const score = [area, balance, skinnyPenalty, aligns, Math.abs(rows - cols)];

                    if (!best) {
                        best = { rows, cols, score };
                        continue;
                    }

                    const a = score;
                    const b = best.score;
                    const better = a[0] < b[0]
                        || (a[0] === b[0] && a[1] < b[1])
                        || (a[0] === b[0] && a[1] === b[1] && a[2] < b[2])
                        || (a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] < b[3])
                        || (a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] < b[4]);

                    if (better) {
                        best = { rows, cols, score };
                    }
                }
            }

            const blockRows = best ? best.rows : 1;
            const blockCols = best ? best.cols : 1;
            const rowOffset = Math.floor((layout.rows - blockRows) / 2);
            const colOffset = Math.floor((layout.cols - blockCols) / 2);
            const padTop = rowOffset * (layout.posterHeight + layout.gap);

            const columns = Array.from({ length: layout.cols }, () => []);
            let index = 0;

            for (let row = 0; row < blockRows; row += 1) {
                for (let col = 0; col < blockCols; col += 1) {
                    if (index >= selection.length) break;
                    const poster = selection[index];
                    const targetCol = colOffset + col;
                    columns[targetCol].push({ poster, slotIndex: index });
                    index += 1;
                }
            }

            return { columns, padTop };
        }

        function buildPosterMeta(poster) {
            const info = getPosterAwardsInfo(poster.id);
            const title = info ? info.title : poster.title || '';
            const year = info ? info.year : '';
            const awards = info ? info.awardsLine : '';
            const star = info && info.isBestPictureNominee;
            return {
                title: escapeHtml(title),
                year: escapeHtml(year),
                awards: escapeHtml(awards),
                rawTitle: title,
                star: star ? 'true' : 'false'
            };
        }

        function updateWallPosterWrap(wrap, poster) {
            const img = wrap.querySelector('.wall-poster');
            if (!img) return;

            const meta = buildPosterMeta(poster);
            wrap.dataset.title = meta.title;
            wrap.dataset.year = meta.year;
            wrap.dataset.awards = meta.awards;
            wrap.dataset.star = meta.star;
            wrap.dataset.movieId = poster.id;
            img.src = poster.url;
            img.alt = meta.rawTitle;
        }

        function animateWallPosterSwap(wrap, poster) {
            const img = wrap.querySelector('.wall-poster');
            if (!img) return;

            const meta = buildPosterMeta(poster);
            const existing = wrap.querySelector('.wall-poster-swap-layer');
            if (existing) {
                existing.remove();
            }
            const overlay = document.createElement('img');
            overlay.className = 'wall-poster wall-poster-swap-layer is-swap-in';
            overlay.src = poster.url;
            overlay.alt = meta.rawTitle;
            overlay.loading = 'eager';
            overlay.decoding = 'async';

            overlay.addEventListener('animationend', () => {
                updateWallPosterWrap(wrap, poster);
                overlay.remove();
            }, { once: true });

            wrap.appendChild(overlay);
        }

        function performCenteredWallBatchSwap(nextSelection) {
            const grid = document.getElementById('postersWallGrid');
            if (!grid) return;
            const wraps = Array.from(grid.querySelectorAll('.wall-poster-wrap[data-slot-index]'));
            if (wraps.length === 0 || nextSelection.length === 0) return;

            wraps
                .sort((a, b) => Number(a.dataset.slotIndex) - Number(b.dataset.slotIndex))
                .forEach((wrap) => {
                    const slotIndex = Number(wrap.dataset.slotIndex);
                    const nextPoster = nextSelection[slotIndex];
                    if (!nextPoster) return;
                    if (postersWallActiveWrap === wrap) {
                        hidePostersWallTooltip();
                    }
                    animateWallPosterSwap(wrap, nextPoster);
                });

            postersWallSelection = nextSelection;
        }

        function preloadWallPosters(selection) {
            if (!selection || selection.length === 0) {
                return Promise.resolve();
            }
            const promises = selection.map(poster => new Promise(resolve => {
                const img = new Image();
                img.onload = () => resolve();
                img.onerror = () => resolve();
                img.src = poster.url;
            }));
            return Promise.all(promises);
        }

        function renderPostersWall({ animate = false, nextSelection = null, layoutOverride = null } = {}) {
            const grid = document.getElementById('postersWallGrid');
            if (!grid) return;
            if (latestMovieStats.length === 0) {
                grid.innerHTML = '';
                postersWallSelection = [];
                return;
            }

            const layout = layoutOverride || getPosterWallLayout();
            grid.style.setProperty('--wall-cols', layout.cols);
            grid.style.setProperty('--wall-rows', layout.rows);
            grid.style.setProperty('--wall-gap', `${layout.gap}px`);
            grid.style.setProperty('--wall-poster-width', `${layout.posterWidth}px`);
            grid.style.setProperty('--wall-poster-height', `${layout.posterHeight}px`);
            const baseColumnHeight = layout.posterHeight * layout.rows + layout.gap * (layout.rows - 1);
            const columnBuffer = 0;
            grid.style.setProperty('--wall-column-height', `${baseColumnHeight + columnBuffer}px`);

            const selection = nextSelection || getPostersWallSelection(layout);
            const isCenteredLayout = selection.length < layout.capacity;
            const canAnimate = animate
                && !isCenteredLayout
                && postersWallSelection.length === selection.length
                && postersWallSelection.length > 0;

            if (postersWallShuffleTimer) {
                clearTimeout(postersWallShuffleTimer);
                postersWallShuffleTimer = null;
            }

            if (!canAnimate) {
                const { columns, padTop } = isCenteredLayout
                    ? getCenteredWallColumns(selection, layout)
                    : { columns: getPostersWallColumns(selection, layout), padTop: 0 };
                grid.innerHTML = columns
                    .map((column) => {
                        return `
                        <div class="wall-column">
                            <div class="wall-column-track" style="--wall-column-offset:${padTop}px;">
                                ${column.map(entry => {
                                    const poster = entry.poster || entry;
                                    const info = getPosterAwardsInfo(poster.id);
                                    const title = info ? escapeHtml(info.title) : escapeHtml(poster.title);
                                    const year = info ? escapeHtml(info.year) : '';
                                    const awards = info ? escapeHtml(info.awardsLine) : '';
                                    const star = info && info.isBestPictureNominee;
                                    const slotIndex = Number.isFinite(entry.slotIndex) ? entry.slotIndex : null;
                                    const slotAttrs = slotIndex !== null
                                        ? ` data-slot-index="${slotIndex}" data-movie-id="${poster.id}"`
                                        : ` data-movie-id="${poster.id}"`;
                                    return `
                                        <div class="wall-poster-wrap" tabindex="0"${slotAttrs} data-title="${title}" data-year="${year}" data-awards="${awards}" data-star="${star}">
                                            <img class="wall-poster" src="${poster.url}" alt="${title}" loading="eager" decoding="async">
                                        </div>
                                    `.trim();
                                }).join('')}
                            </div>
                        </div>
                    `.trim();
                    })
                    .join('');
                postersWallSelection = selection;
                setupLazyPosters();
                hidePostersWallTooltip();
                return;
            }

            const currentColumns = getPostersWallColumns(postersWallSelection, layout);
            const nextColumns = getPostersWallColumns(selection, layout);
            grid.innerHTML = currentColumns
                .map((column, index) => {
                    const nextColumn = nextColumns[index] || [];
                    const delay = index * 120;
                    const currentCount = column.length;
                    const padTop = 0;
                    const shift = currentCount
                        ? (layout.posterHeight * currentCount) + (layout.gap * currentCount) + padTop
                        : 0;
                    const nextCount = nextColumn.length;
                    const nextPadTop = 0;
                    return `
                        <div class="wall-column">
                            <div class="wall-column-track is-shuffling" style="animation-delay:${delay}ms; --wall-column-shift:${shift}px; --wall-column-offset:${padTop}px; --wall-column-offset-start:${padTop}px; --wall-column-offset-end:${nextPadTop}px;">
                                ${column.map(poster => {
                                    const info = getPosterAwardsInfo(poster.id);
                                    const title = info ? escapeHtml(info.title) : escapeHtml(poster.title);
                                    const year = info ? escapeHtml(info.year) : '';
                                    const awards = info ? escapeHtml(info.awardsLine) : '';
                                    const star = info && info.isBestPictureNominee;
                                    return `
                                        <div class="wall-poster-wrap" tabindex="0" data-title="${title}" data-year="${year}" data-awards="${awards}" data-star="${star}">
                                            <img class="wall-poster" src="${poster.url}" alt="${title}" loading="eager" decoding="async">
                                        </div>
                                    `.trim();
                                }).join('')}
                                ${nextColumn.map(poster => {
                                    const info = getPosterAwardsInfo(poster.id);
                                    const title = info ? escapeHtml(info.title) : escapeHtml(poster.title);
                                    const year = info ? escapeHtml(info.year) : '';
                                    const awards = info ? escapeHtml(info.awardsLine) : '';
                                    const star = info && info.isBestPictureNominee;
                                    return `
                                        <div class="wall-poster-wrap" tabindex="0" data-title="${title}" data-year="${year}" data-awards="${awards}" data-star="${star}">
                                            <img class="wall-poster" src="${poster.url}" alt="${title}" loading="eager" decoding="async">
                                        </div>
                                    `.trim();
                                }).join('')}
                            </div>
                        </div>
                    `.trim();
                })
                .join('');
            setupLazyPosters();
            hidePostersWallTooltip();

            const totalDuration = 2500 + (layout.cols - 1) * 120 + 60;
            postersWallShuffleTimer = window.setTimeout(() => {
                postersWallShuffleTimer = null;
                renderPostersWall({ animate: false, nextSelection: selection, layoutOverride: layout });
            }, totalDuration);
        }

        function togglePostersWallFullscreen() {
            const modal = document.getElementById('postersWallModal');
            if (!modal) return;
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                modal.requestFullscreen();
            }
        }

        function updatePostersWallFullscreenState() {
            const button = document.getElementById('postersWallFullscreen');
            if (!button) return;
            if (document.fullscreenElement) {
                button.classList.add('is-active');
            } else {
                button.classList.remove('is-active');
            }
        }

        function hidePostersWallTooltip() {
            const tooltip = document.getElementById('postersWallTooltip');
            if (!tooltip) return;
            tooltip.classList.remove('is-visible');
            tooltip.style.left = '';
            tooltip.style.top = '';
            tooltip.innerHTML = '';
            postersWallActiveWrap = null;
        }

        function showPostersWallTooltip(wrap) {
            const tooltip = document.getElementById('postersWallTooltip');
            const modalContent = document.querySelector('.wall-modal-content');
            if (!tooltip || !modalContent || !wrap) return;
            const title = wrap.dataset.title || '';
            const year = wrap.dataset.year || '';
            const awards = wrap.dataset.awards || '';
            const star = wrap.dataset.star === 'true' ? '<span class="wall-tooltip-star">&#9733;</span>' : '';
            tooltip.innerHTML = `
                <div class="wall-poster-tooltip-title">${title}${star}</div>
                <div class="wall-poster-tooltip-year">${year}</div>
                <div class="wall-poster-tooltip-awards">${awards}</div>
            `.trim();

            const modalRect = modalContent.getBoundingClientRect();
            const wrapRect = wrap.getBoundingClientRect();
            tooltip.classList.add('is-visible');

            requestAnimationFrame(() => {
                const tooltipRect = tooltip.getBoundingClientRect();
                let left = wrapRect.left - modalRect.left + wrapRect.width / 2;
                let top = wrapRect.top - modalRect.top - tooltipRect.height - 10;
                const minLeft = 12 + tooltipRect.width / 2;
                const maxLeft = modalRect.width - 12 - tooltipRect.width / 2;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.max(top, 12);
                tooltip.style.left = `${left}px`;
                tooltip.style.top = `${top}px`;
            });

            postersWallActiveWrap = wrap;
        }

        function showPostersWallUi() {
            const modal = document.getElementById('postersWallModal');
            if (!modal) return;
            modal.classList.remove('is-ui-hidden');
            if (postersWallUiTimer) {
                clearTimeout(postersWallUiTimer);
            }
            postersWallUiTimer = window.setTimeout(() => {
                modal.classList.add('is-ui-hidden');
            }, 5000);
        }

        function clearPostersWallUiTimer() {
            if (postersWallUiTimer) {
                clearTimeout(postersWallUiTimer);
                postersWallUiTimer = null;
            }
        }

        function hidePostersWallCountdown() {
            const countdown = document.getElementById('postersWallCountdown');
            if (!countdown) return;
            countdown.textContent = '';
            countdown.classList.remove('is-visible');
        }

        function updatePostersWallCountdown(value) {
            const countdown = document.getElementById('postersWallCountdown');
            if (!countdown) return;
            countdown.textContent = value;
            countdown.classList.add('is-visible');
        }

        function clearPostersWallInactivityTimers() {
            if (postersWallIdleTimer) {
                clearTimeout(postersWallIdleTimer);
                postersWallIdleTimer = null;
            }
            if (postersWallCountdownTimer) {
                clearInterval(postersWallCountdownTimer);
                postersWallCountdownTimer = null;
            }
        }

        function startPostersWallCountdown() {
            postersWallCountdownValue = 5;
            updatePostersWallCountdown(postersWallCountdownValue);
            if (postersWallCountdownTimer) {
                clearInterval(postersWallCountdownTimer);
            }
            postersWallCountdownTimer = window.setInterval(() => {
                postersWallCountdownValue -= 1;
                if (postersWallCountdownValue <= 0) {
                    clearPostersWallInactivityTimers();
                    hidePostersWallCountdown();
                    shufflePostersWall();
                    resetPostersWallInactivity();
                    return;
                }
                updatePostersWallCountdown(postersWallCountdownValue);
            }, 1000);
        }

        function shufflePostersWall() {
            if (!postersWallOpen) return;
            const layout = getPosterWallLayout();
            const selection = getPostersWallSelection(layout);
            if (selection.length < layout.capacity) {
                preloadWallPosters(selection).then(() => {
                    if (!postersWallOpen) return;
                    performCenteredWallBatchSwap(selection);
                });
                return;
            }

            if (postersWallIsShuffling) return;
            postersWallIsShuffling = true;
            preloadWallPosters(selection).then(() => {
                if (!postersWallOpen) return;
                renderPostersWall({ animate: true, nextSelection: selection, layoutOverride: layout });
            }).finally(() => {
                postersWallIsShuffling = false;
            });
        }

        function resetPostersWallInactivity() {
            clearPostersWallInactivityTimers();
            hidePostersWallCountdown();
            if (!postersWallOpen) return;
            postersWallIdleTimer = window.setTimeout(() => {
                startPostersWallCountdown();
            }, 25000);
        }

        function renderPosterStrip() {
            const section = document.getElementById('posterStripSection');
            const track = document.getElementById('posterStrip');
            const maxPosters = getPosterStripCapacity();
            if (section) {
                posterStripLastWidth = section.getBoundingClientRect().width || section.clientWidth || 0;
            }
            posterStripLastCapacity = maxPosters;
            const data = getDisplayData();
            const seen = new Set();
            const posters = [];

            const maybeAdd = (entry) => {
                if (!entry || !entry.id || seen.has(entry.id)) return;
                const url = getPosterUrl(entry.id);
                if (!url) return;
                seen.add(entry.id);
                posters.push({ id: entry.id, title: entry.title || '', url });
            };

            data.forEach(item => {
                const winnerMatches = matchesSearch(item.winner);
                const filteredNominees = item.nominees.filter(nominee => matchesSearch(nominee));
                const showNominees = state.showNominees && (filteredNominees.length > 0 || !state.searchQuery);
                const showWinner = !state.searchQuery || winnerMatches;

                if (showWinner) {
                    maybeAdd(item.winner);
                }

                if (showNominees) {
                    filteredNominees.forEach(nominee => {
                        maybeAdd(nominee);
                    });
                }
            });

            shuffleArray(posters);
            const visiblePosters = posters.slice(0, maxPosters);

            if (posters.length === 0) {
                section.classList.add('is-empty');
                track.innerHTML = '';
                updatePosterStripInfo(null);
                return;
            }

            track.innerHTML = visiblePosters
                .map((poster, index) => {
                    const delay = Math.min(index * 60, 420);
                    return `
                        <button class="poster-strip-button" type="button" data-movie-id="${poster.id}" aria-label="Highlight ${poster.title}">
                            <img class="poster-strip-image" data-movie-id="${poster.id}" data-src="${poster.url}" alt="${poster.title}" style="animation-delay:${delay}ms">
                        </button>
                    `;
                })
                .join('');
            section.classList.remove('is-empty');
            section.classList.toggle('is-centered', visiblePosters.length < maxPosters);
            updatePosterStripInfo(visiblePosters[0] ? visiblePosters[0].id : null);
            if (!posterStripPaused) {
                startPosterHighlightCycle();
            }
        }

        function shuffleArray(items) {
            for (let i = items.length - 1; i > 0; i -= 1) {
                const j = Math.floor(Math.random() * (i + 1));
                [items[i], items[j]] = [items[j], items[i]];
            }
        }

        function escapeHtml(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function getPosterAwardsInfo(movieId) {
            if (!movieId || !moviesData[movieId]) return null;
            const movie = moviesData[movieId];
            const stats = getGlobalMovieStats();
            const entry = stats[`id:${movieId}`] || { wins: 0, nominations: 0 };
            const title = movie.title || 'Unknown';
            const year = movie.year || 'â€”';
            const displayData = getDisplayData();
            const isBestPictureNominee = displayData.some(item => {
                if (item.category !== 'Best Picture') return false;
                if (item.winner && item.winner.id === movieId) return true;
                return (item.nominees || []).some(nominee => nominee.id === movieId);
            });
            const isBestPictureWinner = displayData.some(item => {
                if (item.category !== 'Best Picture') return false;
                return item.winner && item.winner.id === movieId;
            });
            const wins = entry.wins || 0;
            const nominations = entry.nominations || 0;
            let awardsLine = '';
            let winnerLine = '';
            let nominatedLine = '';
            if (wins === 1) {
                winnerLine = 'Oscar Winner';
            } else if (wins > 1) {
                winnerLine = `Oscar Winner ${wins}X`;
            }
            if (nominations === 1) {
                nominatedLine = 'Nominated';
            } else if (nominations > 1) {
                nominatedLine = `Nominated ${nominations}X`;
            }
            if (winnerLine && nominations === wins) {
                nominatedLine = '';
            }
            if (winnerLine && nominatedLine) {
                awardsLine = `${winnerLine} / ${nominatedLine}`;
            } else {
                awardsLine = winnerLine || nominatedLine;
            }
            return {
                title,
                year,
                awardsLine,
                isWinner: wins > 0,
                isBestPictureNominee,
                isBestPictureWinner
            };
        }

        function updatePosterStripInfo(movieId) {
            const info = document.getElementById('posterStripInfo');
            if (!info) return;
            const posterInfo = getPosterAwardsInfo(movieId);
            if (!posterInfo) {
                info.textContent = '';
                return;
            }
            const titleClass = posterInfo.isWinner ? 'poster-strip-info-title is-winner' : 'poster-strip-info-title';
            const starClass = posterInfo.isBestPictureWinner ? 'poster-strip-info-star is-winner' : 'poster-strip-info-star';
            const star = posterInfo.isBestPictureNominee ? `<span class="${starClass}">&#9733;</span>` : '';
            const awardsClass = posterInfo.isWinner ? 'poster-strip-info-awards is-winner' : 'poster-strip-info-awards';
            info.innerHTML = `
                <button class="${titleClass}" type="button" data-movie-id="${movieId}">${posterInfo.title}${star}</button>
                <div class="poster-strip-info-year">${posterInfo.year}</div>
                <div class="${awardsClass}">${posterInfo.awardsLine}</div>
            `.trim();
        }

        function startPosterHighlightCycle(resume = false) {
            if (!posterStripReady) return;
            if (posterStripHighlightTimer) {
                clearInterval(posterStripHighlightTimer);
                posterStripHighlightTimer = null;
            }
            if (posterStripShuffleTimer) {
                clearTimeout(posterStripShuffleTimer);
                posterStripShuffleTimer = null;
            }

            const posters = Array.from(document.querySelectorAll('.poster-strip-image'));
            if (posters.length === 0) return;

            posters.forEach(poster => poster.classList.remove('is-highlighted'));
            if (!resume) {
                posterStripHighlightIndex = 0;
            } else if (posterStripHighlightIndex >= posters.length) {
                posterStripHighlightIndex = 0;
            }
            posters[posterStripHighlightIndex].classList.add('is-highlighted');
            updatePosterStripInfo(posters[posterStripHighlightIndex].dataset.movieId);

            posterStripHighlightTimer = window.setInterval(() => {
                posters[posterStripHighlightIndex].classList.remove('is-highlighted');
                posterStripHighlightIndex += 1;

                if (posterStripHighlightIndex >= posters.length) {
                    clearInterval(posterStripHighlightTimer);
                    posterStripHighlightTimer = null;
                    if (posterStripPaused) return;
                    posterStripShuffleTimer = window.setTimeout(() => {
                        renderPosterStrip();
                        setupLazyPosters();
                    }, posterStripShuffleDelayMs);
                    return;
                }

                posters[posterStripHighlightIndex].classList.add('is-highlighted');
                updatePosterStripInfo(posters[posterStripHighlightIndex].dataset.movieId);
            }, posterStripHighlightMs);
        }

        function pausePosterStrip() {
            posterStripPaused = true;
            if (posterStripHighlightTimer) {
                clearInterval(posterStripHighlightTimer);
                posterStripHighlightTimer = null;
            }
            if (posterStripShuffleTimer) {
                clearTimeout(posterStripShuffleTimer);
                posterStripShuffleTimer = null;
            }
        }

        function resumePosterStrip() {
            if (!posterStripPaused) return;
            posterStripPaused = false;
            startPosterHighlightCycle(true);
        }

        function autoPausePosterStrip() {
            if (posterStripPaused) return;
            posterStripAutoPaused = true;
            pausePosterStrip();
        }

        function autoResumePosterStrip() {
            if (!posterStripAutoPaused) return;
            posterStripAutoPaused = false;
            resumePosterStrip();
        }

        function highlightPosterById(movieId) {
            const posters = Array.from(document.querySelectorAll('.poster-strip-image'));
            if (posters.length === 0) return;
            const index = posters.findIndex(poster => poster.dataset.movieId === movieId);
            if (index === -1) return;
            posters.forEach(poster => poster.classList.remove('is-highlighted'));
            posterStripHighlightIndex = index;
            posters[posterStripHighlightIndex].classList.add('is-highlighted');
            updatePosterStripInfo(posters[posterStripHighlightIndex].dataset.movieId);
        }

        function getPosterStripCapacity() {
            const section = document.getElementById('posterStripSection');
            const track = document.getElementById('posterStrip');
            if (!section || !track) return 12;
            const styles = getComputedStyle(section);
            const posterWidth = parseFloat(styles.getPropertyValue('--poster-width')) || 64;
            const posterGap = parseFloat(styles.getPropertyValue('--poster-gap')) || 12;
            const padLeft = parseFloat(styles.paddingLeft) || 0;
            const padRight = parseFloat(styles.paddingRight) || 0;
            let sectionWidth = section.getBoundingClientRect().width || section.clientWidth || 0;
            if (!sectionWidth) {
                const container = section.closest('.container');
                sectionWidth = (container && (container.getBoundingClientRect().width || container.clientWidth)) || 0;
            }
            const trackWidth = Math.max(0, sectionWidth - padLeft - padRight);
            if (!trackWidth) return 12;
            const perView = Math.max(1, Math.floor((trackWidth + posterGap) / (posterWidth + posterGap)));
            return perView;
        }

        function renderResults() {
            const container = document.getElementById('resultsContainer');
            const data = getDisplayData();

            let html = '';
            let winnerCount = 0;
            let nomineeCount = 0;
            const movieStats = {};

            if (data.length === 0) {
                container.innerHTML = '<div class="no-results">No results found</div>';
                latestMovieStats = [];
                latestWinnerCount = 0;
                latestNomineeCount = 0;
                updateResultsCount();
                return;
            }

            data.forEach(item => {
                const winnerMatches = matchesSearch(item.winner);
                const nomineeMatches = item.nominees.some(nominee => matchesSearch(nominee));

                if (!winnerMatches && !nomineeMatches) {
                    return;
                }

                const filteredNominees = item.nominees.filter(nominee => matchesSearch(nominee));
                const hasNomineeMatch = filteredNominees.length > 0;
                const nomineesForStats = state.searchQuery ? filteredNominees : item.nominees;
                const showNominees = state.showNominees && (filteredNominees.length > 0 || !state.searchQuery);
                const showWinner = !state.searchQuery || winnerMatches;

                if (!showWinner && !hasNomineeMatch) return;

                if (showWinner) {
                    winnerCount += 1;
                    const winnerTitle = item.winner.title;
                    if (winnerTitle) {
                        const key = `${winnerTitle}__${item.year}`;
                        if (!movieStats[key]) {
                            movieStats[key] = { title: winnerTitle, year: item.year, wins: 0, nominees: 0, id: null };
                        }
                        if (!movieStats[key].id && item.winner.id) {
                            movieStats[key].id = item.winner.id;
                        }
                        movieStats[key].wins += 1;
                    }
                }

                html += `
                    <div class="category-item">
                        <div class="category-name">${item.category}</div>
                        <div class="year-display">${item.year}</div>
                `;

                if (showWinner) {
                    html += `
                        <div class="winner-info">
                            <button class="winner-poster-button movie-link" type="button" data-movie-id="${item.winner.id || ''}" aria-label="View ${item.winner.title}">
                                <img class="winner-poster" data-src="${getPosterUrl(item.winner.id)}" alt="" loading="lazy">
                            </button>
                            <div class="winner-content">
                                <div class="winner-label">Winner</div>
                                <button class="winner-title movie-link" type="button" data-movie-id="${item.winner.id || ''}">
                                    <span class="title-text">${item.winner.title}</span>
                                    <span class="watched-badge" data-movie-id="${item.winner.id || ''}" aria-hidden="true"></span>
                                </button>
                                <div class="winner-names">${item.winner.names.join(', ')}</div>
                            </div>
                        </div>
                    `;
                }

                if (nomineesForStats.length > 0) {
                    nomineesForStats.forEach(nominee => {
                        nomineeCount++;
                        if (nominee.title) {
                            const key = `${nominee.title}__${item.year}`;
                            if (!movieStats[key]) {
                                movieStats[key] = { title: nominee.title, year: item.year, wins: 0, nominees: 0, id: null };
                            }
                            if (!movieStats[key].id && nominee.id) {
                                movieStats[key].id = nominee.id;
                            }
                            movieStats[key].nominees += 1;
                        }
                    });
                }

                if (showNominees) {
                    html += '<div class="nominees-list"><div class="nominees-label">Nominees</div>';
                    const nomineesToShow = state.searchQuery ? filteredNominees : item.nominees;

                    if (nomineesToShow.length === 0) {
                        html += '<div class="no-results compact">No other nominees</div>';
                    } else {
                        nomineesToShow.forEach(nominee => {
                            html += `
                                <div class="nominee-item">
                                    <button class="nominee-title movie-link" type="button" data-movie-id="${nominee.id || ''}">
                                        <span class="title-text">${nominee.title}</span>
                                        <span class="watched-badge" data-movie-id="${nominee.id || ''}" aria-hidden="true"></span>
                                    </button>
                                    <div class="nominee-names">${nominee.names.join(', ')}</div>
                                </div>
                            `;
                        });
                    }

                    html += '</div>';
                }

                html += '</div>';
            });

            container.innerHTML = html || '<div class="no-results">No results match your search</div>';
            setupLazyPosters();
            latestMovieStats = Object.values(movieStats)
                .sort((a, b) => a.title.localeCompare(b.title) || parseInt(a.year) - parseInt(b.year));
            if (!state.showNominees) {
                latestMovieStats = latestMovieStats.filter(movie => movie.wins > 0);
            }
            latestWinnerCount = winnerCount;
            latestNomineeCount = nomineeCount;
            updateResultsCount();
            if (window.updateWatchedBadges) {
                window.updateWatchedBadges();
            }
        }

        function render() {
            renderResults();
            if (posterStripReady) {
                renderPosterStrip();
                setupLazyPosters();
            }
            if (postersWallOpen) {
                renderPostersWall();
            }
        }

        function openPostersWall() {
            const modal = document.getElementById('postersWallModal');
            if (!modal) return;
            if (window.isUserAuthenticated && !window.isUserAuthenticated()) {
                if (window.openAuthModal) {
                    window.openAuthModal();
                }
                return;
            }
            postersWallOpen = true;
            const layout = getPosterWallLayout();
            const selection = getPostersWallSelection(layout);
            preloadWallPosters(selection).then(() => {
                if (!postersWallOpen) return;
                renderPostersWall({ animate: false, nextSelection: selection });
            });
            updatePostersWallFullscreenState();
            showPostersWallUi();
            resetPostersWallInactivity();
            modal.classList.add('is-open');
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
        }

        function closePostersWall() {
            const modal = document.getElementById('postersWallModal');
            if (!modal || !modal.classList.contains('is-open')) return;
            postersWallOpen = false;
            if (document.fullscreenElement) {
                document.exitFullscreen();
            }
            clearPostersWallUiTimer();
            clearPostersWallInactivityTimers();
            hidePostersWallCountdown();
            hidePostersWallTooltip();
            if (postersWallShuffleTimer) {
                clearTimeout(postersWallShuffleTimer);
                postersWallShuffleTimer = null;
            }
            modal.classList.remove('is-open');
            modal.classList.remove('is-ui-hidden');
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
        }

        function schedulePostersWallResize() {
            if (!postersWallOpen) return;
            if (postersWallResizeTimer) {
                clearTimeout(postersWallResizeTimer);
            }
            postersWallResizeTimer = window.setTimeout(() => {
                renderPostersWall();
            }, 200);
        }

        function openMoviesModal() {
            const tableHost = document.getElementById('moviesTable');
            const letterRail = document.getElementById('letterRail');
            if (latestMovieStats.length === 0) {
                tableHost.innerHTML = '<div class="no-results">No movies available</div>';
                letterRail.innerHTML = '';
            } else {
                renderMoviesTable(tableHost);
                renderLetterRail(letterRail, tableHost);
            }

            const modal = document.getElementById('moviesModal');
            modal.classList.add('is-open');
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
            
            // Reset scroll position to top
            tableHost.scrollTop = 0;
        }

        function closeMoviesModal() {
            const modal = document.getElementById('moviesModal');
            if (!modal.classList.contains('is-open')) return;
            modal.classList.remove('is-open');
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
        }

        function setupLazyPosters() {
            const posters = document.querySelectorAll('.winner-poster[data-src], .poster-strip-image[data-src], .wall-poster[data-src]');
            if (posters.length === 0) return;

            if (!('IntersectionObserver' in window)) {
                posters.forEach(img => {
                    if (!img.dataset.src) {
                        img.removeAttribute('data-src');
                        return;
                    }
                    img.src = img.dataset.src;
                    img.removeAttribute('data-src');
                });
                return;
            }

            const observer = new IntersectionObserver((entries, obs) => {
                entries.forEach(entry => {
                    if (!entry.isIntersecting) return;
                    const img = entry.target;
                    if (!img.dataset.src) {
                        img.removeAttribute('data-src');
                        obs.unobserve(img);
                        return;
                    }
                    img.src = img.dataset.src;
                    img.removeAttribute('data-src');
                    obs.unobserve(img);
                });
            }, { rootMargin: '200px 0px' });

            posters.forEach(img => observer.observe(img));
        }

        function openMovieDetail(movieId) {
            const movie = moviesData[movieId];
            if (!movie) return;
            if (window.setCurrentMovieId) {
                window.setCurrentMovieId(movieId);
            }

            const poster = document.getElementById('movieDetailPoster');
            if (movie.poster_path) {
                poster.src = `https://image.tmdb.org/t/p/w342${movie.poster_path}`;
                poster.alt = movie.title;
            } else {
                poster.removeAttribute('src');
                poster.alt = '';
            }

            document.getElementById('movieDetailTitle').textContent = movie.title || 'Unknown';

            const meta = [];
            if (movie.year) meta.push(`Year: ${movie.year}`);
            if (movie.release_date) meta.push(`Release: ${movie.release_date}`);
            if (typeof movie.vote_average === 'number') meta.push(`Score: ${movie.vote_average.toFixed(1)}`);
            if (movie.original_language) meta.push(`Lang: ${movie.original_language.toUpperCase()}`);
            document.getElementById('movieDetailMeta').textContent = meta.join(' Â· ');

            document.getElementById('movieDetailOverview').textContent = movie.overview || 'No overview available.';

            const categoriesEl = document.getElementById('movieDetailCategories');
            const yearData = oscarsData[movie.year] || {};
            const title = movie.title || '';
            categoriesEl.innerHTML = categoryOrder
                .map(category => {
                    const entry = yearData[category];
                    let status = 'none';
                    let winnerNames = [];
                    let nomineeNames = [];
                    if (entry && entry.winner && entry.winner.title === title) {
                        status = 'win';
                        if (entry.winner.names && entry.winner.names.length) {
                            winnerNames = entry.winner.names.filter(Boolean);
                        }
                    }
                    if (entry && (entry.nominees || []).some(n => n.title === title)) {
                        const nominees = (entry.nominees || []).filter(n => n.title === title);
                        nomineeNames = nominees.flatMap(n => n.names || []).filter(Boolean);
                        if (nomineeNames.length) {
                            status = status === 'win' ? status : 'nominee';
                        }
                    }
                    const uniqueWinnerNames = Array.from(new Set(winnerNames));
                    const uniqueNomineeNames = Array.from(new Set(nomineeNames));
                    const namesHtml = [
                        uniqueWinnerNames.length
                            ? `<span class="category-names category-names--winner">${uniqueWinnerNames.join(', ')}</span>`
                            : '',
                        uniqueNomineeNames.length
                            ? `<span class="category-names category-names--nominee">${uniqueNomineeNames.join(', ')}</span>`
                            : ''
                    ].filter(Boolean).join(
                        uniqueWinnerNames.length && uniqueNomineeNames.length ? ', ' : ''
                    );
                    return `
                        <div class="category-chip category-${status}">
                            ${category}
                            ${namesHtml ? `<span class="category-names-inline">${namesHtml}</span>` : ''}
                        </div>
                    `;
                })
                .join('');

            if (window.prepareMovieProviders) {
                window.prepareMovieProviders(movie);
            }

            const modal = document.getElementById('movieDetailModal');
            const detailCard = modal.querySelector('.detail-card');
            if (detailCard) {
                detailCard.scrollTop = 0;
            }
            modal.classList.add('is-open');
            modal.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');
        }

        function closeMovieDetail() {
            const modal = document.getElementById('movieDetailModal');
            if (!modal.classList.contains('is-open')) return;
            modal.classList.remove('is-open');
            modal.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('modal-open');
            if (window.setCurrentMovieId) {
                window.setCurrentMovieId(null);
            }
        }

        function renderMoviesTable(tableHost) {
            const globalStats = getGlobalMovieStats();
            const getScore = (movie) => {
                if (!movie.id || !moviesData[movie.id]) {
                    return null;
                }
                const score = moviesData[movie.id].vote_average;
                return typeof score === 'number' ? score : null;
            };
            const getGlobalKey = (movie) => {
                if (movie.id) return `id:${movie.id}`;
                return `title:${movie.title || ''}__${movie.year || ''}`;
            };
            const getWins = (movie) => {
                const entry = globalStats[getGlobalKey(movie)];
                return entry ? entry.wins : movie.wins;
            };
            const getTotalNominations = (movie) => {
                const entry = globalStats[getGlobalKey(movie)];
                if (entry) return entry.nominations;
                return movie.wins + movie.nominees;
            };
            const sorted = [...latestMovieStats].sort((a, b) => {
                const direction = tableSort.direction === 'asc' ? 1 : -1;
                if (tableSort.key === 'title') {
                    return (a.title.localeCompare(b.title) || (parseInt(a.year) - parseInt(b.year))) * direction;
                }
                if (tableSort.key === 'year') {
                    const aYear = a.year ? parseInt(a.year, 10) : 0;
                    const bYear = b.year ? parseInt(b.year, 10) : 0;
                    return (aYear - bYear) * direction;
                }
                if (tableSort.key === 'watched') {
                    const aWatched = window.isMovieWatched ? (window.isMovieWatched(a.id) ? 1 : 0) : 0;
                    const bWatched = window.isMovieWatched ? (window.isMovieWatched(b.id) ? 1 : 0) : 0;
                    return (aWatched - bWatched) * direction;
                }
                if (tableSort.key === 'wins') {
                    return (getWins(a) - getWins(b)) * direction;
                }
                if (tableSort.key === 'nominees') {
                    return (getTotalNominations(a) - getTotalNominations(b)) * direction;
                }
                if (tableSort.key === 'score') {
                    const aScore = getScore(a) ?? -1;
                    const bScore = getScore(b) ?? -1;
                    return (aScore - bScore) * direction;
                }
                return (a[tableSort.key] - b[tableSort.key]) * direction;
            });

            const titleCounts = sorted.reduce((acc, movie) => {
                acc[movie.title] = (acc[movie.title] || 0) + 1;
                return acc;
            }, {});

            const header = (label, key) => {
                const isActive = tableSort.key === key;
                const indicator = isActive ? (tableSort.direction === 'asc' ? 'â–²' : 'â–¼') : 'â†•';
                return `
                    <button class="sort-button" type="button" data-sort="${key}">
                        ${label} <span class="sort-indicator">${indicator}</span>
                    </button>
                `;
            };

            tableHost.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>${header('Title', 'title')}</th>
                            <th class="watched-header">${header('Watched', 'watched')}</th>
                            <th>${header('Year', 'year')}</th>
                            <th>${header('Wins', 'wins')}</th>
                            <th>${header('Nominees', 'nominees')}</th>
                            <th>${header('Score', 'score')}</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sorted
                            .map(movie => {
                                const yearLabel = movie.year || 'N/A';
                                const titleLabel = titleCounts[movie.title] > 1
                                    ? `${movie.title} (${movie.year})`
                                    : movie.title;
                                const firstLetterMatch = movie.title.trim().toUpperCase().match(/[A-Z]/);
                                const letter = firstLetterMatch ? firstLetterMatch[0] : '#';
                                const score = getScore(movie);
                                const scoreLabel = score === null ? 'â€”' : score.toFixed(1);
                                const winsCount = getWins(movie);
                                const totalNominations = getTotalNominations(movie);
                                return `
                                    <tr data-letter="${letter}">
                                        <td>
                                            <button class="movie-link" type="button" data-movie-id="${movie.id || ''}">
                                                ${titleLabel}
                                            </button>
                                        </td>
                                        <td class="watched-cell">
                                            <span class="watched-badge" data-movie-id="${movie.id || ''}" aria-hidden="true"></span>
                                        </td>
                                        <td>${yearLabel}</td>
                                        <td>${winsCount}</td>
                                        <td>${totalNominations}</td>
                                        <td>${scoreLabel}</td>
                                    </tr>
                                `;
                            })
                            .join('')}
                    </tbody>
                </table>
            `;

            if (window.updateWatchedBadges) {
                window.updateWatchedBadges();
            }

            tableHost.querySelectorAll('.sort-button').forEach(button => {
                button.addEventListener('click', () => {
                    const key = button.getAttribute('data-sort');
                    if (tableSort.key === key) {
                        tableSort.direction = tableSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        tableSort.key = key;
                        tableSort.direction = 'asc';
                    }
                    renderMoviesTable(tableHost);
                    renderLetterRail(document.getElementById('letterRail'), tableHost);
                });
            });

            tableHost.querySelectorAll('.movie-link').forEach(button => {
                button.addEventListener('click', () => {
                    const movieId = button.getAttribute('data-movie-id');
                    if (movieId) {
                        openMovieDetail(movieId);
                    }
                });
            });
        }

        function renderLetterRail(letterRail, tableHost) {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            const available = new Set(
                Array.from(tableHost.querySelectorAll('tbody tr'))
                    .map(row => row.getAttribute('data-letter'))
            );

            letterRail.innerHTML = letters
                .map(letter => {
                    const isAvailable = available.has(letter);
                    return `
                        <button class="letter-button" type="button" data-letter="${letter}" ${isAvailable ? '' : 'disabled'}>
                            ${letter}
                        </button>
                    `;
                })
                .join('');

            letterRail.querySelectorAll('.letter-button').forEach(button => {
                button.addEventListener('click', () => {
                    const targetLetter = button.getAttribute('data-letter');
                    const targetRow = tableHost.querySelector(`tbody tr[data-letter="${targetLetter}"]`);
                    if (targetRow) {
                        targetRow.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });
        }

        // Initialize the app
        init();
    </script>

<script type="module">
  // Import Firebase SDK
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
  import { countries, countryByCode } from "./js/countries.js";
  import { oscarsData, moviesData } from './js/data.js';
  import { 
    getAuth, 
    GoogleAuthProvider, 
    signInWithPopup, 
    signOut, 
    onAuthStateChanged 
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";
  import {
    getFirestore,
    collection,
    getDoc,
    getDocs,
    doc,
    setDoc,
    deleteDoc
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

  // Your web app's Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyD4N_m38-gDoTdWFGHMWFboQE2g7d7NVV0",
    authDomain: "oscareight-482706.firebaseapp.com",
    projectId: "oscareight-482706",
    storageBucket: "oscareight-482706.firebasestorage.app",
    messagingSenderId: "784257979968",
    appId: "1:784257979968:web:6e0a786464c6698b7271a5"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const provider = new GoogleAuthProvider();

  // DOM elements
  const signInButton = document.getElementById('signInButton');
  const signOutButton = document.getElementById('signOutButton');
  const userMenu = document.getElementById('userMenu');
  const userMenuButton = document.getElementById('userMenuButton');
  const userDropdown = document.getElementById('userDropdown');
  const userName = document.getElementById('userName');
  const userEmail = document.getElementById('userEmail');
  const userAvatar = document.getElementById('userAvatar');
  const userDropdownName = document.getElementById('userDropdownName');
  const userCountry = document.getElementById('userCountry');
  const userCountrySelect = document.getElementById('userCountrySelect');
  const userCountryToggle = document.getElementById('userCountryToggle');
  const authModal = document.getElementById('authModal');
  const closeAuthModal = document.getElementById('closeAuthModal');
  const googleSignInButton = document.getElementById('googleSignInButton');
  const badgesButton = document.getElementById('badgesButton');
  const badgesModal = document.getElementById('badgesModal');
  const badgesClose = document.getElementById('badgesClose');
  const badgesGrid = document.getElementById('badgesGrid');
  const badgesSummary = document.getElementById('badgesSummary');
  const badgeStatusFilter = document.getElementById('badgeStatusFilter');
  const badgeTypeFilter = document.getElementById('badgeTypeFilter');
  const badgeVariantFilter = document.getElementById('badgeVariantFilter');
  const badgeFilterCount = document.getElementById('badgeFilterCount');
  const watchedLabel = document.getElementById('watchedLabel');
  const watchedToggle = document.getElementById('watchedToggle');
  const postersWallOpenButton = document.getElementById('postersWallOpen');
  const movieDetailProviders = document.getElementById('movieDetailProviders');

  const categoryOrder = [
    'Best Picture',
    'Best Director',
    'Best Actor',
    'Best Actress',
    'Best Supporting Actor',
    'Best Supporting Actress',
    'Best Original Screenplay',
    'Best Adapted Screenplay'
  ];

  let currentUser = null;
  let currentCountryCode = null;
  let watchedIds = new Set();
  let currentMovieId = null;
  let currentMovieData = null;
  let providersRequestId = 0;
  let badgeFilters = {
    status: 'earned',
    type: 'all',
    variant: 'all'
  };
  const watchProvidersCache = new Map();
  let providersToggle = null;
  let providersContent = null;
  let providersExpanded = false;
  let badgeDefinitions = [];
  let currentBadgeFile = 'badges-b8w'; // Format: badges-{key}
  let badgeResolvers = {}; // Custom resolvers from badge files

  // Dynamic badge definition loading
  async function loadBadgeDefinitions(badgeFileName) {
    try {
      console.log(`Loading badge definitions from ${badgeFileName}...`);
      const module = await import(`./js/${badgeFileName}.js`);
      badgeDefinitions = module.generateBadges(oscarsData, categoryOrder);
      badgeResolvers = module.badgeResolvers || {};
      console.log(`âœ“ Loaded ${badgeDefinitions.length} badges from ${badgeFileName}`);
      if (module.badgeMetadata) {
        console.log(`Badge set: ${module.badgeMetadata.name} (v${module.badgeMetadata.version})`);
      }
      populateBadgeFilters();
      return true;
    } catch (error) {
      console.error(`âœ— Failed to load ${badgeFileName}:`, error);
      // Fallback to default if not already trying default
      if (badgeFileName !== 'badges-b8w') {
        console.log('Falling back to badges-b8w...');
        return loadBadgeDefinitions('badges-b8w');
      }
      return false;
    }
  }

  function populateBadgeFilters() {
    if (!badgeTypeFilter || !badgeVariantFilter) return;
    
    // Collect unique types and their display names
    const typeMap = new Map();
    const hasWinners = badgeDefinitions.some(b => b.includeNominees === false);
    const hasNominees = badgeDefinitions.some(b => b.includeNominees === true);
    
    badgeDefinitions.forEach(badge => {
      if (badge.type && !typeMap.has(badge.type)) {
        let displayName = badge.type;
        // Generate friendly display names
        if (badge.type === 'big8') displayName = 'Big 8 Complete';
        else if (badge.type === 'category-decade') displayName = 'Category Masters';
        else if (badge.type === 'era-challenge') displayName = 'Era Challenges';
        else if (badge.type === 'achievement') displayName = 'Achievements';
        else {
          // Convert kebab-case to Title Case
          displayName = badge.type.split('-').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
          ).join(' ');
        }
        typeMap.set(badge.type, displayName);
      }
    });
    
    // Populate type filter
    const currentTypeValue = badgeTypeFilter.value;
    badgeTypeFilter.innerHTML = '<option value="all">All</option>';
    Array.from(typeMap.entries()).sort((a, b) => a[1].localeCompare(b[1])).forEach(([value, name]) => {
      const option = document.createElement('option');
      option.value = value;
      option.textContent = name;
      badgeTypeFilter.appendChild(option);
    });
    // Restore previous selection if it still exists
    if (Array.from(badgeTypeFilter.options).some(opt => opt.value === currentTypeValue)) {
      badgeTypeFilter.value = currentTypeValue;
    }
    
    // Populate variant filter
    const currentVariantValue = badgeVariantFilter.value;
    badgeVariantFilter.innerHTML = '<option value="all">All</option>';
    if (hasWinners) {
      const winnersOption = document.createElement('option');
      winnersOption.value = 'winners';
      winnersOption.textContent = 'Winners';
      badgeVariantFilter.appendChild(winnersOption);
    }
    if (hasNominees) {
      const nomineesOption = document.createElement('option');
      nomineesOption.value = 'all-nominees';
      nomineesOption.textContent = 'Nominees';
      badgeVariantFilter.appendChild(nomineesOption);
    }
    // Restore previous selection if it still exists
    if (Array.from(badgeVariantFilter.options).some(opt => opt.value === currentVariantValue)) {
      badgeVariantFilter.value = currentVariantValue;
    }
  }

  async function loadUserBadgePreference(user) {
    if (!user) return 'b8w';
    try {
      const userRef = doc(db, 'users', user.uid);
      const snapshot = await getDoc(userRef);
      const data = snapshot.exists() ? snapshot.data() : null;
      let badgeKey = data?.badges;
      
      // If badges field is missing, save the default
      if (!badgeKey) {
        badgeKey = 'b8w';
        await setDoc(userRef, { badges: badgeKey }, { merge: true });
        console.log(`Saved default badge key: ${badgeKey}`);
      }
      
      console.log(`User badge key: ${badgeKey}`);
      return badgeKey;
    } catch (error) {
      console.error('Badge preference load error:', error);
      return 'badges-default';
    }
  }

  // Legacy badge generation (no longer used, kept for reference)
  function generateBadgeDefinitions() {
    const badges = [];
    const years = Object.keys(oscarsData).map(Number).sort((a, b) => a - b);
    const minYear = years[0];
    const maxYear = years[years.length - 1];

    // Rule 1: Big 8 Complete per year (all years from min to max)
    for (let year = minYear; year <= maxYear; year++) {
      if (oscarsData[year]) {
        // Winners only
        badges.push({
          id: `big8-${year}-winners`,
          title: 'Big 8 Complete',
          subtitle: 'Winners',
          type: 'big8',
          year: year,
          periodLabel: String(year),
          includeNominees: false
        });
        // All nominees
        badges.push({
          id: `big8-${year}-all`,
          title: 'Big 8 Complete',
          subtitle: 'Nominees',
          type: 'big8',
          year: year,
          periodLabel: String(year),
          includeNominees: true
        });
      }
    }

    // Rule 2: Category Master per decade (all decades from min to max, all 8 categories)
    const categoryBadgeNames = {
      'Best Picture': 'Best Picture Master',
      'Best Director': 'Best Director Master',
      'Best Actor': 'Best Actor Master',
      'Best Actress': 'Best Actress Master',
      'Best Supporting Actor': 'Best Supporting Actor Master',
      'Best Supporting Actress': 'Best Supporting Actress Master',
      'Best Original Screenplay': 'Best Original Screenplay Master',
      'Best Adapted Screenplay': 'Best Adapted Screenplay Master'
    };

    const minDecade = Math.floor(minYear / 10) * 10;
    const maxDecade = Math.floor(maxYear / 10) * 10;

    for (let decadeStart = minDecade; decadeStart <= maxDecade; decadeStart += 10) {
      categoryOrder.forEach(category => {
        const categoryKey = category.toLowerCase().replace(/\s+/g, '-');
        const decadeLabel = `${decadeStart}s`;
        
        // Winners only
        badges.push({
          id: `${categoryKey}-${decadeStart}s-winners`,
          title: categoryBadgeNames[category],
          subtitle: 'Winners',
          type: 'category-decade',
          category: category,
          decadeStart: decadeStart,
          periodLabel: decadeLabel,
          includeNominees: false
        });
        // All nominees
        badges.push({
          id: `${categoryKey}-${decadeStart}s-all`,
          title: categoryBadgeNames[category],
          subtitle: 'Nominees',
          type: 'category-decade',
          category: category,
          decadeStart: decadeStart,
          periodLabel: decadeLabel,
          includeNominees: true
        });
      });
    }

    return badges;
  }

  function updateCountryDisplay(code, name, suffix = '') {
    if (!userCountry) return;
    currentCountryCode = code || null;
    if (!code || !name) {
      userCountry.textContent = 'Not set';
      return;
    }
    userCountry.textContent = `${name} (${code})${suffix}`;
  }

  function populateCountrySelect(selectedCode) {
    if (!userCountrySelect) return;
    userCountrySelect.innerHTML = '';
    userCountrySelect.classList.add('is-hidden');
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select country...';
    userCountrySelect.appendChild(placeholder);
    countries.forEach((country) => {
      const option = document.createElement('option');
      option.value = country.code;
      option.textContent = `${country.name} (${country.code})`;
      if (selectedCode && country.code === selectedCode) {
        option.selected = true;
      }
      userCountrySelect.appendChild(option);
    });
  }

  function getCountryFromTimeZone() {
    const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || '';
    const map = {
      'Europe/Sofia': 'BG',
      'Europe/London': 'GB',
      'Europe/Paris': 'FR',
      'Europe/Berlin': 'DE',
      'Europe/Rome': 'IT',
      'Europe/Madrid': 'ES',
      'Europe/Amsterdam': 'NL',
      'Europe/Brussels': 'BE',
      'Europe/Prague': 'CZ',
      'Europe/Warsaw': 'PL',
      'Europe/Vienna': 'AT',
      'Europe/Zurich': 'CH',
      'Europe/Stockholm': 'SE',
      'Europe/Oslo': 'NO',
      'Europe/Copenhagen': 'DK',
      'Europe/Helsinki': 'FI',
      'Europe/Bucharest': 'RO',
      'Europe/Athens': 'GR',
      'Europe/Belgrade': 'RS',
      'Europe/Istanbul': 'TR',
      'Europe/Kiev': 'UA',
      'Europe/Kyiv': 'UA',
      'Europe/Moscow': 'RU',
      'America/New_York': 'US',
      'America/Chicago': 'US',
      'America/Denver': 'US',
      'America/Los_Angeles': 'US',
      'America/Phoenix': 'US',
      'America/Toronto': 'CA',
      'America/Vancouver': 'CA',
      'America/Montreal': 'CA',
      'America/Halifax': 'CA',
      'America/Winnipeg': 'CA',
      'America/Edmonton': 'CA',
      'America/Calgary': 'CA',
      'America/Mexico_City': 'MX',
      'America/Sao_Paulo': 'BR',
      'America/Buenos_Aires': 'AR',
      'America/Lima': 'PE',
      'America/Santiago': 'CL',
      'America/Bogota': 'CO',
      'Asia/Tokyo': 'JP',
      'Asia/Seoul': 'KR',
      'Asia/Shanghai': 'CN',
      'Asia/Hong_Kong': 'HK',
      'Asia/Singapore': 'SG',
      'Asia/Kolkata': 'IN',
      'Asia/Dubai': 'AE',
      'Asia/Manila': 'PH',
      'Asia/Bangkok': 'TH',
      'Asia/Jakarta': 'ID',
      'Asia/Taipei': 'TW',
      'Asia/Kuala_Lumpur': 'MY',
      'Australia/Sydney': 'AU',
      'Australia/Melbourne': 'AU',
      'Australia/Brisbane': 'AU',
      'Australia/Perth': 'AU',
      'Australia/Adelaide': 'AU',
      'Australia/Darwin': 'AU',
      'Pacific/Auckland': 'NZ',
      'Africa/Johannesburg': 'ZA',
      'Africa/Cairo': 'EG',
      'Africa/Nairobi': 'KE',
      'Africa/Lagos': 'NG',
      'Africa/Casablanca': 'MA'
    };
    return map[timeZone] || null;
  }

  function getCountryFromLocale() {
    const locale = navigator.language || (navigator.languages && navigator.languages[0]) || '';
    const parts = locale.split('-');
    if (parts.length >= 2) {
      const region = parts[1].toUpperCase();
      if (/^[A-Z]{2}$/.test(region)) return region;
    }
    return getCountryFromTimeZone();
  }

  async function ensureUserCountry(user) {
    if (!user) return;
    try {
      const userRef = doc(db, 'users', user.uid);
      const snapshot = await getDoc(userRef);
      const existing = snapshot.exists() ? snapshot.data() : null;
      if (existing && existing.countryCode && existing.countryName) return;
      const legacyCode = existing && existing.country ? existing.country : null;
      const countryCode = legacyCode || getCountryFromLocale();
      if (!countryCode) return;
      const countryName = countryByCode.get(countryCode);
      if (!countryName) return;
      await setDoc(userRef, {
        countryCode,
        countryName,
        countrySource: 'locale',
        countryUpdatedAt: new Date().toISOString()
      }, { merge: true });
    } catch (error) {
      console.error('Country save error:', error);
    }
  }

  async function loadUserCountry(user) {
    if (!user || !userCountry) return;
    try {
      const userRef = doc(db, 'users', user.uid);
      const snapshot = await getDoc(userRef);
      const data = snapshot.exists() ? snapshot.data() : null;
      const storedCode = data && (data.countryCode || data.country) ? (data.countryCode || data.country) : null;
      const storedName = data && data.countryName ? data.countryName : null;
      const detectedCode = getCountryFromLocale();
      const detectedName = detectedCode ? countryByCode.get(detectedCode) : null;
      const normalizedStoredName = storedCode ? (storedName || countryByCode.get(storedCode)) : null;
      if (storedCode && normalizedStoredName) {
        updateCountryDisplay(storedCode, normalizedStoredName);
        populateCountrySelect(storedCode);
      } else if (detectedCode && detectedName) {
        updateCountryDisplay(detectedCode, detectedName, ' (auto)');
        populateCountrySelect(detectedCode);
      } else {
        updateCountryDisplay(null, null);
        populateCountrySelect('');
      }
    } catch (error) {
      console.error('Country load error:', error);
      updateCountryDisplay(null, null);
      populateCountrySelect('');
    }
  }

  function getEffectiveCountryCode() {
    return currentCountryCode || getCountryFromLocale();
  }

  function isMovieDetailOpen() {
    const modal = document.getElementById('movieDetailModal');
    return Boolean(modal && modal.classList.contains('is-open'));
  }

  function updateProvidersToggle() {
    if (!providersToggle || !providersContent) return;
    providersToggle.setAttribute('aria-expanded', providersExpanded ? 'true' : 'false');
    providersToggle.textContent = providersExpanded ? 'Hide' : 'Show';
    providersContent.classList.toggle('is-open', providersExpanded);
  }

  function updateProvidersCountry() {
    const providersCountry = document.getElementById('providersCountry');
    if (!providersCountry) return;
    providersCountry.textContent = getEffectiveCountryCode() || '';
  }

  function setupProvidersSection() {
    if (!movieDetailProviders || movieDetailProviders.dataset.ready === 'true') return;
    movieDetailProviders.dataset.ready = 'true';
    movieDetailProviders.innerHTML = `
      <div class="providers-header">
        <span>Where to watch</span>
        <div class="providers-actions">
          <span id="providersCountry" class="providers-country"></span>
          <button id="providersToggle" class="providers-toggle tooltip-trigger" type="button" aria-expanded="false">Show</button>
        </div>
      </div>
      <div id="providersContent" class="providers-content"></div>
    `;
    providersToggle = document.getElementById('providersToggle');
    providersContent = document.getElementById('providersContent');
    providersToggle.addEventListener('click', () => {
      if (!currentUser) {
        openAuthModal();
        return;
      }
      providersExpanded = !providersExpanded;
      updateProvidersToggle();
      if (providersExpanded && currentMovieData) {
        loadMovieProviders(currentMovieData);
      }
    });
    updateProvidersToggle();
    updateProvidersCountry();
    updateProvidersAccess();
  }

  function renderProvidersShell(contentHtml) {
    if (!movieDetailProviders) return;
    setupProvidersSection();
    if (!providersContent) return;
    movieDetailProviders.classList.remove('is-hidden');
    updateProvidersCountry();
    providersContent.innerHTML = contentHtml;
  }

  function renderProvidersMessage(message) {
    renderProvidersShell(`<div class="providers-empty">${message}</div>`);
  }

  function renderProvidersLoading() {
    renderProvidersShell('<div class="providers-loading">Loading watch providersâ€¦</div>');
  }

  function hideProviders() {
    if (!movieDetailProviders) return;
    movieDetailProviders.classList.add('is-hidden');
    movieDetailProviders.innerHTML = '';
    movieDetailProviders.dataset.ready = '';
    providersToggle = null;
    providersContent = null;
    providersExpanded = false;
  }

  function prepareMovieProviders(movie) {
    currentMovieData = movie;
    if (!movieDetailProviders) return;
    if (!currentUser) {
      setupProvidersSection();
      renderProvidersMessage('Sign in to see where to watch.');
      updateProvidersAccess();
      return;
    }
    providersRequestId += 1;
    setupProvidersSection();
    if (!providersContent) return;
    providersExpanded = false;
    updateProvidersToggle();
    updateProvidersCountry();
    providersContent.innerHTML = '';
    movieDetailProviders.classList.remove('is-hidden');
  }

  function renderProvidersData(data) {
    const providers = data && data.providers ? data.providers : null;
    if (!providers) {
      renderProvidersMessage('No watch providers available.');
      return;
    }
    const groups = [
      { key: 'flatrate', label: 'Stream' },
      { key: 'rent', label: 'Rent' },
      { key: 'buy', label: 'Buy' }
    ];
    const groupHtml = groups
      .map(({ key, label }) => {
        const list = Array.isArray(providers[key]) ? providers[key] : [];
        if (!list.length) return '';
        const items = list
          .slice()
          .sort((a, b) => (a.display_priority || 0) - (b.display_priority || 0))
          .map((provider) => {
            const logo = provider.logo_path
              ? `https://image.tmdb.org/t/p/w92${provider.logo_path}`
              : '';
            const logoHtml = logo
              ? `<img class="provider-logo" src="${logo}" alt="${provider.provider_name}" loading="lazy">`
              : '<span class="provider-logo" aria-hidden="true"></span>';
            return `
              <div class="provider-card">
                ${logoHtml}
                <span class="provider-name">${provider.provider_name}</span>
              </div>
            `;
          })
          .join('');
        return `
          <div class="provider-group">
            <div class="provider-group-title">${label}</div>
            <div class="provider-list">${items}</div>
          </div>
        `;
      })
      .filter(Boolean)
      .join('');

    if (!groupHtml) {
      renderProvidersMessage('No watch providers available.');
      return;
    }

    renderProvidersShell(`<div class="providers-groups">${groupHtml}</div>`);
  }

  async function loadMovieProviders(movie) {
    if (!movieDetailProviders) return;
    setupProvidersSection();
    currentMovieData = movie;
    if (!providersContent) return;
    if (!movie || !movie.tmdb_id) {
      hideProviders();
      return;
    }
    if (!currentUser) {
      renderProvidersMessage('Sign in to see where to watch.');
      return;
    }
    const countryCode = getEffectiveCountryCode();
    if (!countryCode) {
      renderProvidersMessage('Set a country to see watch providers.');
      return;
    }

    const cacheKey = `${movie.tmdb_id}:${countryCode}`;
    if (watchProvidersCache.has(cacheKey)) {
      renderProvidersData(watchProvidersCache.get(cacheKey));
      return;
    }

    const requestId = providersRequestId + 1;
    providersRequestId = requestId;
    renderProvidersLoading();

    try {
      const token = await currentUser.getIdToken(true);
      const url = `https://oscareight-api-389635339946.europe-west3.run.app/watch-providers?movieId=${movie.tmdb_id}&country=${countryCode}`;
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${token}`
        }
      });
      if (providersRequestId !== requestId) return;
      if (!response.ok) {
        if (response.status === 401) {
          renderProvidersMessage('Sign in to see where to watch.');
        } else {
          renderProvidersMessage('Could not load watch providers.');
        }
        return;
      }
      const data = await response.json();
      watchProvidersCache.set(cacheKey, data);
      renderProvidersData(data);
    } catch (error) {
      if (providersRequestId !== requestId) return;
      renderProvidersMessage('Could not load watch providers.');
    }
  }

  window.loadMovieProviders = loadMovieProviders;
  window.prepareMovieProviders = prepareMovieProviders;

  function getBig8YearMovieIds(year, includeNominees) {
    const yearData = oscarsData[year];
    if (!yearData) return [];
    const ids = new Set();
    categoryOrder.forEach((category) => {
      const categoryData = yearData[category];
      if (!categoryData) return;
      if (categoryData.winner && categoryData.winner.id) {
        ids.add(categoryData.winner.id);
      }
      if (includeNominees && Array.isArray(categoryData.nominees)) {
        categoryData.nominees.forEach((nominee) => {
          if (nominee && nominee.id) {
            ids.add(nominee.id);
          }
        });
      }
    });
    return Array.from(ids);
  }

  function getBestPictureDecadeMovieIds(decadeStart, includeNominees) {
    const ids = new Set();
    const endYear = decadeStart + 9;
    for (let year = decadeStart; year <= endYear; year += 1) {
      const yearData = oscarsData[year];
      if (!yearData) continue;
      const categoryData = yearData['Best Picture'];
      if (!categoryData) continue;
      if (categoryData.winner && categoryData.winner.id) {
        ids.add(categoryData.winner.id);
      }
      if (includeNominees && Array.isArray(categoryData.nominees)) {
        categoryData.nominees.forEach((nominee) => {
          if (nominee && nominee.id) {
            ids.add(nominee.id);
          }
        });
      }
    }
    return Array.from(ids);
  }

  function getCategoryDecadeMovieIds(category, decadeStart, includeNominees) {
    const ids = new Set();
    const endYear = decadeStart + 9;
    for (let year = decadeStart; year <= endYear; year += 1) {
      const yearData = oscarsData[year];
      if (!yearData) continue;
      const categoryData = yearData[category];
      if (!categoryData) continue;
      if (categoryData.winner && categoryData.winner.id) {
        ids.add(categoryData.winner.id);
      }
      if (includeNominees && Array.isArray(categoryData.nominees)) {
        categoryData.nominees.forEach((nominee) => {
          if (nominee && nominee.id) {
            ids.add(nominee.id);
          }
        });
      }
    }
    return Array.from(ids);
  }

  function getBadgeTargetIds(badge) {
    // Check if there's a custom resolver for this badge type
    if (badgeResolvers[badge.type]) {
      return badgeResolvers[badge.type](badge, oscarsData, categoryOrder);
    }
    
    // Default built-in types
    if (badge.type === 'big8') {
      return getBig8YearMovieIds(badge.year, badge.includeNominees);
    }
    if (badge.type === 'best-picture-decade') {
      return getBestPictureDecadeMovieIds(badge.decadeStart, badge.includeNominees);
    }
    if (badge.type === 'category-decade') {
      return getCategoryDecadeMovieIds(badge.category, badge.decadeStart, badge.includeNominees);
    }
    if (badge.type === 'era-challenge') {
      return getEraChallengeMovieIds(badge.category, badge.startYear, badge.endYear, badge.includeNominees);
    }
    return [];
  }

  function getEraChallengeMovieIds(category, startYear, endYear, includeNominees) {
    const ids = new Set();
    for (let year = startYear; year <= endYear; year += 1) {
      const yearData = oscarsData[year];
      if (!yearData) continue;
      const categoryData = yearData[category];
      if (!categoryData) continue;
      if (categoryData.winner && categoryData.winner.id) {
        ids.add(categoryData.winner.id);
      }
      if (includeNominees && Array.isArray(categoryData.nominees)) {
        categoryData.nominees.forEach((nominee) => {
          if (nominee && nominee.id) {
            ids.add(nominee.id);
          }
        });
      }
    }
    return Array.from(ids);
  }

  function getBadgeProgress(badge) {
    const ids = getBadgeTargetIds(badge);
    let watchedCount = 0;
    ids.forEach((id) => {
      if (watchedIds.has(id)) {
        watchedCount += 1;
      }
    });
    const totalCount = ids.length;
    return {
      watchedCount,
      totalCount,
      isComplete: totalCount > 0 && watchedCount === totalCount
    };
  }

  function renderBadges() {
    if (!badgesGrid) return;
    if (!currentUser) {
      badgesGrid.innerHTML = '<div class="empty-state">Sign in to see your badges.</div>';
      if (badgesSummary) {
        badgesSummary.textContent = '';
      }
      if (badgeFilterCount) {
        badgeFilterCount.textContent = '';
      }
      return;
    }

    // Apply filters
    const filteredBadges = badgeDefinitions.filter((badge) => {
      const progress = getBadgeProgress(badge);
      
      // Status filter
      if (badgeFilters.status !== 'all') {
        if (badgeFilters.status === 'earned' && !progress.isComplete) return false;
        if (badgeFilters.status === 'locked' && progress.watchedCount > 0) return false;
        if (badgeFilters.status === 'almost-done') {
          const remaining = progress.totalCount - progress.watchedCount;
          if (remaining !== 1) return false;
        }
        if (badgeFilters.status === 'in-progress') {
          const remaining = progress.totalCount - progress.watchedCount;
          if (progress.watchedCount === 0 || progress.isComplete || remaining === 1) return false;
        }
      }
      
      // Type filter
      if (badgeFilters.type !== 'all' && badge.type !== badgeFilters.type) return false;
      
      // Variant filter
      if (badgeFilters.variant !== 'all') {
        if (badgeFilters.variant === 'winners' && badge.includeNominees) return false;
        if (badgeFilters.variant === 'all-nominees' && !badge.includeNominees) return false;
      }
      
      return true;
    });

    let earnedCount = 0;
    const cards = filteredBadges.map((badge) => {
      const progress = getBadgeProgress(badge);
      if (progress.isComplete) {
        earnedCount += 1;
      }
      
      const countLabel = progress.totalCount
        ? `${progress.watchedCount}/${progress.totalCount}`
        : '0/0';
      
      const percentage = progress.totalCount > 0 
        ? (progress.watchedCount / progress.totalCount) * 100 
        : 0;
      
      const circumference = 2 * Math.PI * 36; // radius = 36
      const dashOffset = circumference - (percentage / 100) * circumference;
      
      const statusClass = progress.isComplete ? 'is-earned' : (progress.watchedCount > 0 ? 'is-in-progress' : 'is-locked');
      
      return `
        <div class="badge-card ${statusClass}">
          <div class="badge-header">
            <div class="badge-subtitle">${badge.subtitle}</div>
            <div class="badge-count">${countLabel}</div>
          </div>
          <div class="badge-ring-container">
            <div class="badge-ring">
              <svg viewBox="0 0 80 80">
                <circle class="badge-ring-bg" cx="40" cy="40" r="36"></circle>
                <circle class="badge-ring-progress" cx="40" cy="40" r="36"
                  stroke-dasharray="${circumference}"
                  stroke-dashoffset="${dashOffset}"></circle>
              </svg>
              <div class="badge-period">${badge.periodLabel || ''}</div>
            </div>
          </div>
          <div class="badge-title">${badge.title}</div>
        </div>
      `;
    }).join('');
    
    // Add placeholders to fill the last row
    // With scrollbar always visible, we have consistent width
    const badgeCount = filteredBadges.length;
    const badgesPerRow = 6; // Fixed: modal width allows 6 badges with scrollbar
    const remainder = badgeCount % badgesPerRow;
    const placeholdersNeeded = remainder > 0 ? badgesPerRow - remainder : 0;
    const placeholders = Array(placeholdersNeeded).fill('<div class="badge-placeholder"></div>').join('');
    
    badgesGrid.innerHTML = (cards + placeholders) || '<div class="empty-state">No badges match the filters.</div>';
    
    if (badgesSummary) {
      badgesSummary.textContent = `${earnedCount}/${badgeDefinitions.length} earned`;
    }
    
    if (badgeFilterCount) {
      badgeFilterCount.textContent = `Showing ${filteredBadges.length} of ${badgeDefinitions.length}`;
    }
  }

  function openBadgesModal() {
    if (!badgesModal) return;
    // Reset filters to default
    badgeFilters = {
      status: 'earned',
      type: 'all',
      variant: 'all'
    };
    // Update filter dropdowns
    const statusFilter = document.getElementById('badgeStatusFilter');
    const typeFilter = document.getElementById('badgeTypeFilter');
    const variantFilter = document.getElementById('badgeVariantFilter');
    if (statusFilter) statusFilter.value = 'earned';
    if (typeFilter) typeFilter.value = 'all';
    if (variantFilter) variantFilter.value = 'all';
    renderBadges();
    // Reset scroll position to top
    const badgeBody = badgesModal.querySelector('.badge-body');
    if (badgeBody) badgeBody.scrollTop = 0;
    badgesModal.classList.add('is-open');
    badgesModal.setAttribute('aria-hidden', 'false');
    document.body.classList.add('modal-open');
  }

  function closeBadgesModal() {
    if (!badgesModal || !badgesModal.classList.contains('is-open')) return;
    badgesModal.classList.remove('is-open');
    badgesModal.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('modal-open');
  }

  function updateWatchedToggle() {
    if (!watchedToggle) return;
    const isAuthed = Boolean(currentUser);
    const isWatched = isAuthed && currentMovieId && watchedIds.has(currentMovieId);
    const tooltipText = !isAuthed ? 'Sign in to track watched' : (isWatched ? 'Unmark watched' : 'Mark as watched');
    const labelText = isWatched ? 'Watched' : 'Not watched';
    watchedToggle.classList.toggle('is-watched', Boolean(isWatched));
    watchedToggle.classList.toggle('is-locked', !isAuthed);
    watchedToggle.setAttribute('aria-pressed', isWatched ? 'true' : 'false');
    watchedToggle.setAttribute('aria-label', tooltipText);
    watchedToggle.setAttribute('data-tooltip', tooltipText);
    if (watchedLabel) {
      watchedLabel.textContent = labelText;
    }
    updateWatchedBadges();
    renderBadges();
    updatePostersWallAccess();
    updateProvidersAccess();
  }

  function updatePostersWallAccess() {
    if (!postersWallOpenButton) return;
    const isAuthed = Boolean(currentUser);
    const tooltipText = isAuthed ? 'Poster Wall' : 'Sign in to open Poster Wall';
    postersWallOpenButton.classList.toggle('is-locked', !isAuthed);
    postersWallOpenButton.setAttribute('aria-label', tooltipText);
    postersWallOpenButton.setAttribute('data-tooltip', tooltipText);
  }

  function updateProvidersAccess() {
    if (!providersToggle) return;
    const isAuthed = Boolean(currentUser);
    const tooltipText = isAuthed ? 'Where to watch' : 'Sign in to see where to watch';
    providersToggle.classList.toggle('is-locked', !isAuthed);
    providersToggle.setAttribute('aria-label', tooltipText);
    providersToggle.setAttribute('data-tooltip', tooltipText);
  }

  function openAuthModal() {
    if (!authModal) return;
    authModal.classList.add('show');
  }

  window.openAuthModal = openAuthModal;
  window.isUserAuthenticated = () => Boolean(currentUser);

  function updateWatchedBadges() {
    const badges = document.querySelectorAll('.watched-badge[data-movie-id]');
    badges.forEach((badge) => {
      const movieId = badge.dataset.movieId;
      const isWatched = Boolean(currentUser) && movieId && watchedIds.has(movieId);
      badge.classList.toggle('is-watched', isWatched);
      badge.setAttribute('data-state', isWatched ? 'watched' : 'unwatched');
    });
  }

  function isMovieWatched(movieId) {
    return Boolean(currentUser) && Boolean(movieId) && watchedIds.has(movieId);
  }

  function setCurrentMovieId(movieId) {
    currentMovieId = movieId;
    if (!movieId) {
      currentMovieData = null;
    }
    updateWatchedToggle();
  }

  window.setCurrentMovieId = setCurrentMovieId;
  window.updateWatchedBadges = updateWatchedBadges;
  window.isMovieWatched = isMovieWatched;
  window.getWatchedIds = () => (currentUser ? watchedIds : null);

  async function loadWatchedIds(user) {
    watchedIds = new Set();
    if (!user) {
      updateWatchedToggle();
      return;
    }
    try {
      const snapshot = await getDocs(collection(db, 'users', user.uid, 'watched'));
      snapshot.forEach((docSnap) => {
        watchedIds.add(docSnap.id);
      });
    } catch (error) {
      console.error('Watched load error:', error);
    }
    updateWatchedToggle();
    updateWatchedBadges();
    if (window.updateResultsCount) {
      window.updateResultsCount();
    }
  }

  // Open sign-in modal
  signInButton.addEventListener('click', () => {
    authModal.classList.add('show');
  });

  // Close sign-in modal
  closeAuthModal.addEventListener('click', () => {
    authModal.classList.remove('show');
  });

  // Close modal when clicking outside
  authModal.addEventListener('click', (e) => {
    if (e.target === authModal) {
      authModal.classList.remove('show');
    }
  });

  // Sign in with Google
  googleSignInButton.addEventListener('click', async () => {
    try {
      const result = await signInWithPopup(auth, provider);
      const user = result.user;
      console.log('User signed in:', user.displayName);
      authModal.classList.remove('show');
    } catch (error) {
      console.error('Sign in error:', error.code, error.message);
      alert('Sign in failed. Please try again.');
    }
  });

  // Sign out
  signOutButton.addEventListener('click', async () => {
    try {
      await signOut(auth);
      console.log('User signed out');
      userDropdown.classList.remove('show');
    } catch (error) {
      console.error('Sign out error:', error);
      alert('Sign out failed. Please try again.');
    }
  });

  if (badgesButton) {
    badgesButton.addEventListener('click', () => {
      userDropdown.classList.remove('show');
      if (!currentUser) {
        authModal.classList.add('show');
        return;
      }
      openBadgesModal();
    });
  }

  if (badgesClose) {
    badgesClose.addEventListener('click', closeBadgesModal);
  }

  if (badgesModal) {
    badgesModal.addEventListener('click', (e) => {
      if (e.target === badgesModal) {
        closeBadgesModal();
      }
    });
  }

  if (badgeStatusFilter) {
    badgeStatusFilter.addEventListener('change', (e) => {
      badgeFilters.status = e.target.value;
      renderBadges();
    });
  }

  if (badgeTypeFilter) {
    badgeTypeFilter.addEventListener('change', (e) => {
      badgeFilters.type = e.target.value;
      renderBadges();
    });
  }

  if (badgeVariantFilter) {
    badgeVariantFilter.addEventListener('change', (e) => {
      badgeFilters.variant = e.target.value;
      renderBadges();
    });
  }

  watchedToggle.addEventListener('click', async () => {
    if (!currentMovieId) return;
    if (!currentUser) {
      authModal.classList.add('show');
      return;
    }
    const docRef = doc(db, 'users', currentUser.uid, 'watched', currentMovieId);
    const isWatched = watchedIds.has(currentMovieId);
    try {
      if (isWatched) {
        await deleteDoc(docRef);
        watchedIds.delete(currentMovieId);
      } else {
        await setDoc(docRef, { watched: true }, { merge: true });
        watchedIds.add(currentMovieId);
      }
      updateWatchedToggle();
      updateWatchedBadges();
      if (window.updateResultsCount) {
        window.updateResultsCount();
      }
    } catch (error) {
      console.error('Watched toggle error:', error);
      alert('Could not update watched status. Please try again.');
    }
  });

  // Toggle user dropdown menu
  userMenuButton.addEventListener('click', () => {
    userDropdown.classList.toggle('show');
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!userMenu.contains(e.target)) {
      userDropdown.classList.remove('show');
    }
  });

  // Listen for authentication state changes
  onAuthStateChanged(auth, async (user) => {
    if (user) {
      // User is signed in
      console.log('User is authenticated:', user.displayName);
      currentUser = user;
      
      // Load user's badge key
      const badgeKey = await loadUserBadgePreference(user);
      currentBadgeFile = `badges-${badgeKey}`;
      
      // Load the badge definitions
      await loadBadgeDefinitions(currentBadgeFile);
      
      // Update badge button text with key
      if (badgesButton) {
        badgesButton.textContent = `Badges (${badgeKey})`;
      }
      
      await ensureUserCountry(user);
      await loadUserCountry(user);
      loadWatchedIds(user);
      signInButton.style.display = 'none';
      userMenu.style.display = 'block';
      userName.textContent = user.displayName || 'User';
      userDropdownName.textContent = user.displayName || 'User';
      userEmail.textContent = user.email;
      userAvatar.src = user.photoURL || 'https://via.placeholder.com/32';
      renderBadges();
      if (isMovieDetailOpen() && currentMovieData) {
        prepareMovieProviders(currentMovieData);
      }
    } else {
      // User is signed out
      console.log('User is not authenticated');
      currentUser = null;
      watchedIds = new Set();
      
      // Load default badges for unauthenticated users
      currentBadgeFile = 'badges-b8w';
      await loadBadgeDefinitions(currentBadgeFile);
      updateWatchedToggle();
      closeBadgesModal();
      signInButton.style.display = 'flex';
      userMenu.style.display = 'none';
      if (badgesButton) {
        badgesButton.textContent = 'Badges';
      }
      updateCountryDisplay(null, null);
      if (userBadgeKey) {
        userBadgeKey.textContent = '';
      }
      if (isMovieDetailOpen() && currentMovieData) {
        prepareMovieProviders(currentMovieData);
      }
      if (userCountrySelect) {
        userCountrySelect.innerHTML = '';
      }
      if (window.updateResultsCount) {
        window.updateResultsCount();
      }
    }
  });

  if (userCountrySelect) {
    userCountrySelect.addEventListener('change', async (event) => {
      if (!currentUser) {
        authModal.classList.add('show');
        return;
      }
      const countryCode = event.target.value;
      const countryName = countryByCode.get(countryCode);
      if (!countryCode || !countryName) {
        updateCountryDisplay(null, null);
        return;
      }
      try {
        const userRef = doc(db, 'users', currentUser.uid);
        await setDoc(userRef, {
          countryCode,
          countryName,
          countrySource: 'manual',
          countryUpdatedAt: new Date().toISOString()
        }, { merge: true });
        updateCountryDisplay(countryCode, countryName);
        userCountrySelect.classList.add('is-hidden');
        if (isMovieDetailOpen() && currentMovieData && providersExpanded) {
          loadMovieProviders(currentMovieData);
        }
      } catch (error) {
        console.error('Country update error:', error);
        alert('Could not update country. Please try again.');
      }
    });
  }

  if (userCountryToggle && userCountrySelect) {
    userCountryToggle.addEventListener('click', () => {
      userCountrySelect.classList.toggle('is-hidden');
      if (!userCountrySelect.classList.contains('is-hidden')) {
        userCountrySelect.focus();
      }
    });
  }

  // Load default badge definitions on page load
  loadBadgeDefinitions('badges-b8w');
</script>
</body>
</html>
